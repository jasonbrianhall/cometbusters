#include <GL/glew.h>
#include <GL/gl.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
//#include <pango/pango.h>
#include "cometbuster.h"
#include "visualization.h"
#include "cometbuster_splashscreen.h"
#include "comet_lang.h"

#ifdef ANDROID
#include <SDL.h>
#else
#include <SDL2/SDL.h>
#endif

#ifdef ExternalSound
#include "audio_wad.h"
#endif

#ifdef ANDROID
    #define glGenVertexArrays(n, arrays) (void)0
    #define glBindVertexArray(array) (void)0
    #define glDeleteVertexArrays(n, arrays) (void)0
#endif

static int isGLInitialized = 0;

// FreeType includes for dynamic TTF rendering
#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_GLYPH_H

// Include the base64-encoded TTF font header
#include "Monospace.h"  // Generated by ttf_to_base64_header.py

static void ft_init_from_base64(void);

// FreeType font system globals
static FT_Library ft_library = NULL;
static FT_Face ft_face = NULL;
static unsigned char *ft_font_buffer = NULL;


static GLuint global_vao = 0;

// Simple matrix math
typedef struct {
    float m[16];
} Mat4;

static Mat4 mat4_identity(void) {
    Mat4 m = {0};
    m.m[0] = m.m[5] = m.m[10] = m.m[15] = 1.0f;
    return m;
}

static Mat4 mat4_ortho(float left, float right, float bottom, float top, float near, float far) {
    Mat4 m = mat4_identity();
    m.m[0] = 2.0f / (right - left);
    m.m[5] = 2.0f / (top - bottom);
    m.m[10] = -2.0f / (far - near);
    m.m[12] = -(right + left) / (right - left);
    m.m[13] = -(top + bottom) / (top - bottom);
    m.m[14] = -(far + near) / (far - near);
    return m;
}

// Vertex format
typedef struct {
    float x, y;
    float r, g, b, a;
} Vertex;

// Global GL state
typedef struct {
    GLuint program;
    GLuint vao;
    GLuint vbo;
    Mat4 projection;
    float color[4];
} GLRenderState;

static GLRenderState gl_state = {0};

// Shader sources
#ifndef ANDROID
// Desktop OpenGL 3.3+
static const char *vertex_shader = 
    "#version 330 core\n"
    "layout(location = 0) in vec2 position;\n"
    "layout(location = 1) in vec4 color;\n"
    "uniform mat4 projection;\n"
    "out vec4 vertexColor;\n"
    "void main() {\n"
    "    gl_Position = projection * vec4(position, 0.0, 1.0);\n"
    "    vertexColor = color;\n"
    "}\n";

static const char *fragment_shader =
    "#version 330 core\n"
    "in vec4 vertexColor;\n"
    "out vec4 FragColor;\n"
    "void main() {\n"
    "    FragColor = vertexColor;\n"
    "}\n";

#else
// OpenGL ES 3.0+ (Android)
static const char *vertex_shader = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"
    "layout(location = 1) in vec4 color;\n"
    "uniform mat4 projection;\n"
    "out vec4 vertexColor;\n"
    "void main() {\n"
    "    vertexColor = color;\n"
    "    gl_Position = projection * vec4(position, 0.0, 1.0);\n"
    "}\n";

static const char *fragment_shader =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec4 vertexColor;\n"
    "out vec4 FragColor;\n"
    "void main() {\n"
    "    FragColor = vertexColor;\n"
    "}\n";
#endif


static GLuint compile_shader(const char *src, GLenum type) {
    const char *type_str = (type == GL_VERTEX_SHADER) ? "VERTEX" : "FRAGMENT";
    GLuint shader = glCreateShader(type);
    
    if (!shader) {
        SDL_Log("[Comet Busters] [GL] CRITICAL: Failed to create %s shader object\n", type_str);
        return 0;
    }
    
    glShaderSource(shader, 1, &src, NULL);
    glCompileShader(shader);
    
    int success;
    char log[1024];
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(shader, sizeof(log), NULL, log);
        SDL_Log("[Comet Busters] [GL] %s shader compile error: %s\n", type_str, log);
        SDL_Log("[Comet Busters] [GL] Source:\n%s\n", src);
        glDeleteShader(shader);
        return 0;
    }
    return shader;
}

static GLuint create_program(const char *vs_src, const char *fs_src) {
    GLuint vs = compile_shader(vs_src, GL_VERTEX_SHADER);
    GLuint fs = compile_shader(fs_src, GL_FRAGMENT_SHADER);
    
    if (!vs || !fs) {
        SDL_Log("[Comet Busters] [GL] CRITICAL: Shader compilation failed\n");
        if (vs) glDeleteShader(vs);
        if (fs) glDeleteShader(fs);
        return 0;
    }
    
    GLuint prog = glCreateProgram();
    if (!prog) {
        SDL_Log("[Comet Busters] [GL] CRITICAL: Failed to create program object\n");
        glDeleteShader(vs);
        glDeleteShader(fs);
        return 0;
    }
    
    glAttachShader(prog, vs);
    glAttachShader(prog, fs);
    glLinkProgram(prog);
    
    int success;
    char log[1024];
    glGetProgramiv(prog, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(prog, sizeof(log), NULL, log);
        SDL_Log("[Comet Busters] [GL] Program link error: %s\n", log);
        glDeleteShader(vs);
        glDeleteShader(fs);
        glDeleteProgram(prog);
        return 0;
    }
    
    glDeleteShader(vs);
    glDeleteShader(fs);
    return prog;
}

void gl_init(void) {
    if (gl_state.program) return;
    
    SDL_Log("[Comet Busters] [GL] Initializing GL Renderer\n");
    glGenVertexArrays(1, &global_vao);
    
    gl_state.program = create_program(vertex_shader, fragment_shader);
    
    if (!gl_state.program) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "[Comet Busters] [GL] ERROR: create_program failed, program == 0");
    } else {
        SDL_Log("[Comet Busters] [GL] Program created: %u\n", gl_state.program);
    }
    
    
    glGenVertexArrays(1, &gl_state.vao);
    glGenBuffers(1, &gl_state.vbo);
    
    glBindVertexArray(gl_state.vao);
    glBindBuffer(GL_ARRAY_BUFFER, gl_state.vbo);
    // INCREASED BUFFER SIZE: 1M vertices instead of 100K to prevent overflow
    glBufferData(GL_ARRAY_BUFFER, 1000000 * sizeof(Vertex), NULL, GL_DYNAMIC_DRAW);
    
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, x));
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, r));
    glEnableVertexAttribArray(1);
    
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);
    
    gl_state.color[0] = 1.0f;
    gl_state.color[1] = 1.0f;
    gl_state.color[2] = 1.0f;
    gl_state.color[3] = 1.0f;
    
    // Initialize FreeType font system with base64-encoded TTF
    ft_init_from_base64();
    
    SDL_Log("[Comet Busters] [GL] GL renderer initialized\n");
}

static void draw_vertices(Vertex *verts, int count, GLenum mode) {
    glUseProgram(gl_state.program);
    
    GLint proj_loc = glGetUniformLocation(gl_state.program, "projection");
    glUniformMatrix4fv(proj_loc, 1, GL_FALSE, gl_state.projection.m);
    
    glBindBuffer(GL_ARRAY_BUFFER, gl_state.vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, count * sizeof(Vertex), verts);
    
    glBindVertexArray(gl_state.vao);
    glDrawArrays(mode, 0, count);
}

// ============================================================================
// HIGH-LEVEL DRAWING API
// ============================================================================

void gl_setup_2d_projection(int width, int height) {
    // Set projection matrix to match the actual viewport dimensions
    // This is CRITICAL to prevent text clipping when viewport != 1920x1080
    // Use the actual viewport width and height passed in
    if (width <= 0) width = 1920;     // Fallback to default if invalid
    if (height <= 0) height = 1080;   // Fallback to default if invalid
    gl_state.projection = mat4_ortho(0, width, height, 0, -1, 1);
}

void gl_restore_projection(void) {
    // No-op in modern GL
}

void gl_set_color(float r, float g, float b) {
    gl_state.color[0] = r;
    gl_state.color[1] = g;
    gl_state.color[2] = b;
    gl_state.color[3] = 1.0f;
}

void gl_set_color_alpha(float r, float g, float b, float a) {
    gl_state.color[0] = r;
    gl_state.color[1] = g;
    gl_state.color[2] = b;
    gl_state.color[3] = a;
}

// ============================================================================
// TEXT RENDERING - Dynamic TTF Rendering with FreeType and Base64 Font
// ============================================================================

// Initialize FreeType library and load base64-encoded TTF font
static void ft_init_from_base64(void) {
    if (ft_library) {
        SDL_Log("[Comet Busters] [FONT] FreeType already initialized\n");
        return;
    }
    
    // Initialize FreeType library
    FT_Error error = FT_Init_FreeType(&ft_library);
    if (error) {
        SDL_Log("[Comet Busters] [FONT] ERROR: Failed to initialize FreeType: %d\n", error);
        return;
    }
    
    SDL_Log("[Comet Busters] [FONT] FreeType initialized\n");
    
    // Decode base64 font data
    SDL_Log("[Comet Busters] [FONT] Decoding base64 TTF font data (%zu bytes)...\n", MONOSPACE_FONT_B64_SIZE);
    
    // Use the base64_decode function from Monospace.h
    size_t decoded_size = 0;
    int decode_result = base64_decode(MONOSPACE_FONT_B64, MONOSPACE_FONT_B64_SIZE, &ft_font_buffer, &decoded_size);
    
    if (decode_result != 0 || !ft_font_buffer) {
        SDL_Log("[Comet Busters] [FONT] ERROR: Failed to decode base64 font data\n");
        FT_Done_FreeType(ft_library);
        ft_library = NULL;
        return;
    }
    
    SDL_Log("[Comet Busters] [FONT] Base64 decoded: %zu bytes -> %zu bytes\n", MONOSPACE_FONT_B64_SIZE, decoded_size);
    
    // Load the font face from memory
    error = FT_New_Memory_Face(ft_library, ft_font_buffer, (FT_Long)decoded_size, 0, &ft_face);
    if (error) {
        SDL_Log("[Comet Busters] [FONT] ERROR: Failed to load TTF face: %d\n", error);
        free(ft_font_buffer);
        ft_font_buffer = NULL;
        FT_Done_FreeType(ft_library);
        ft_library = NULL;
        return;
    }
    
    SDL_Log("[Comet Busters] [FONT] TTF font loaded successfully\n");
    SDL_Log("[Comet Busters] [FONT] Font family: %s, style: %s\n", ft_face->family_name, ft_face->style_name);
}

// Cleanup FreeType resources
static void ft_cleanup(void) {
    if (ft_face) {
        FT_Done_Face(ft_face);
        ft_face = NULL;
    }
    if (ft_library) {
        FT_Done_FreeType(ft_library);
        ft_library = NULL;
    }
    if (ft_font_buffer) {
        free(ft_font_buffer);
        ft_font_buffer = NULL;
    }
}

// UTF-8 Decoder: Convert UTF-8 byte sequence to Unicode codepoint
// Returns the Unicode codepoint and updates bytes_read with number of bytes consumed
// Handles:
//   - ASCII (1 byte): 0x00-0x7F
//   - Latin Extended (2 bytes): 0xC0-0xDF
//   - Cyrillic, CJK, etc. (3 bytes): 0xE0-0xEF
//   - Full Unicode (4 bytes): 0xF0-0xF7
static unsigned int utf8_to_codepoint(const unsigned char *str, int *bytes_read) {
    if (!str || !bytes_read) {
        *bytes_read = 0;
        return 0;
    }
    
    unsigned char c0 = str[0];
    
    // Single byte (ASCII: 0x00-0x7F)
    if (c0 < 0x80) {
        *bytes_read = 1;
        return c0;
    }
    
    // Two bytes (Latin Extended: 0xC0-0xDF)
    // Examples: á (0xE1), é (0xE9), ñ (0xF1)
    if ((c0 & 0xE0) == 0xC0) {
        *bytes_read = 2;
        unsigned char c1 = str[1];
        if ((c1 & 0xC0) != 0x80) {
            return 0;  // Invalid UTF-8
        }
        return ((c0 & 0x1F) << 6) | (c1 & 0x3F);
    }
    
    // Three bytes (Cyrillic, Greek, etc: 0xE0-0xEF)
    // Examples: А (0x0410), Б (0x0411), etc.
    if ((c0 & 0xF0) == 0xE0) {
        *bytes_read = 3;
        unsigned char c1 = str[1];
        unsigned char c2 = str[2];
        if ((c1 & 0xC0) != 0x80 || (c2 & 0xC0) != 0x80) {
            return 0;  // Invalid UTF-8
        }
        return ((c0 & 0x0F) << 12) | ((c1 & 0x3F) << 6) | (c2 & 0x3F);
    }
    
    // Four bytes (CJK, Emoji: 0xF0-0xF7)
    if ((c0 & 0xF8) == 0xF0) {
        *bytes_read = 4;
        unsigned char c1 = str[1];
        unsigned char c2 = str[2];
        unsigned char c3 = str[3];
        if ((c1 & 0xC0) != 0x80 || (c2 & 0xC0) != 0x80 || (c3 & 0xC0) != 0x80) {
            return 0;  // Invalid UTF-8
        }
        return ((c0 & 0x07) << 18) | ((c1 & 0x3F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);
    }
    
    // Invalid UTF-8 sequence
    *bytes_read = 1;
    return 0;
}

// Calculate actual text width based on FreeType glyph metrics
static float gl_calculate_text_width(const char *text, int font_size) {
    if (!text || !text[0] || !ft_face) return 0.0f;
    
    // Set font size (in 1/64th of a point, so multiply by 64)
    FT_Error error = FT_Set_Pixel_Sizes(ft_face, 0, font_size);
    if (error) {
        SDL_Log("[Comet Busters] [FONT] Warning: Failed to set font size\n");
        return 0.0f;
    }
    
    float width = 0.0f;
    
    // Process UTF-8 text
    for (int i = 0; text[i]; ) {
        int bytes_read = 0;
        unsigned int codepoint = utf8_to_codepoint((const unsigned char*)&text[i], &bytes_read);
        
        if (bytes_read == 0) {
            i++;
            continue;
        }
        
        // Load the glyph and get metrics
        FT_UInt glyph_index = FT_Get_Char_Index(ft_face, codepoint);
        error = FT_Load_Glyph(ft_face, glyph_index, FT_LOAD_DEFAULT);
        
        if (!error) {
            // Use advance width from the glyph slot
            width += (float)(ft_face->glyph->advance.x >> 6);  // Convert from 1/64th pixel to pixels
        }
        
        i += bytes_read;
    }
    
    return width;
}

void gl_draw_text_simple(const char *text, int x, int y, int font_size) {
    if (!text || !text[0] || !ft_face) return;
    
    // Set font size
    FT_Error error = FT_Set_Pixel_Sizes(ft_face, 0, font_size);
    if (error) {
        SDL_Log("[Comet Busters] [FONT] Warning: Failed to set font size\n");
        return;
    }
    
    // Disable scissor test to prevent text clipping
    glDisable(GL_SCISSOR_TEST);
    
    float current_x = (float)x;
    float baseline_y = (float)y;
    float line_height = (float)font_size * 1.2f;  // Line height with 20% spacing
    
    // Build vertex array
    static Vertex verts[20000000];
    int vert_count = 0;
    const int MAX_VERTS = 19999999;
    
    // Process UTF-8 text
    for (int i = 0; text[i] && vert_count < MAX_VERTS - 6; ) {
        int bytes_read = 0;
        unsigned int codepoint = utf8_to_codepoint((const unsigned char*)&text[i], &bytes_read);
        
        if (bytes_read == 0) {
            i++;
            continue;
        }
        
        // Handle newline character
        if (codepoint == '\n') {
            current_x = (float)x;
            baseline_y += line_height;
            i += bytes_read;
            continue;
        }
        
        // Get glyph index and load it
        FT_UInt glyph_index = FT_Get_Char_Index(ft_face, codepoint);
        error = FT_Load_Glyph(ft_face, glyph_index, FT_LOAD_RENDER);
        
        if (error) {
            // Skip glyphs that can't be loaded, but advance position
            if (FT_Load_Glyph(ft_face, glyph_index, FT_LOAD_DEFAULT) == 0) {
                current_x += (float)(ft_face->glyph->advance.x >> 6);
            }
            i += bytes_read;
            continue;
        }
        
        FT_GlyphSlot slot = ft_face->glyph;
        FT_Bitmap *bitmap = &slot->bitmap;
        
        if (bitmap->buffer && bitmap->width > 0 && bitmap->rows > 0) {
            // Render glyph bitmap as vertices
            float glyph_x = current_x + slot->bitmap_left;
            float glyph_y = baseline_y - slot->bitmap_top;
            
            for (int row = 0; row < (int)bitmap->rows && vert_count < MAX_VERTS - 6; row++) {
                float pixel_y = glyph_y + row;
                
                for (int col = 0; col < (int)bitmap->width && vert_count < MAX_VERTS - 6; col++) {
                    unsigned char pixel_value = bitmap->buffer[row * bitmap->pitch + col];
                    
                    if (pixel_value > 3) {
                        float pixel_x = glyph_x + col;
                        float alpha = gl_state.color[3] * ((float)pixel_value / 255.0f);
                        
                        float r = gl_state.color[0];
                        float g = gl_state.color[1];
                        float b = gl_state.color[2];
                        
                        // Create two triangles for the pixel
                        verts[vert_count++] = {pixel_x, pixel_y, r, g, b, alpha};
                        verts[vert_count++] = {pixel_x + 1.0f, pixel_y, r, g, b, alpha};
                        verts[vert_count++] = {pixel_x + 1.0f, pixel_y + 1.0f, r, g, b, alpha};
                        
                        verts[vert_count++] = {pixel_x, pixel_y, r, g, b, alpha};
                        verts[vert_count++] = {pixel_x + 1.0f, pixel_y + 1.0f, r, g, b, alpha};
                        verts[vert_count++] = {pixel_x, pixel_y + 1.0f, r, g, b, alpha};
                    }
                }
            }
        }
        
        // Advance to next character position
        current_x += (float)(slot->advance.x >> 6);
        i += bytes_read;
    }
    
    // Draw all glyphs at once
    if (vert_count > 0) {
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        draw_vertices(verts, vert_count, GL_TRIANGLES);
    }
}


void gl_draw_line(float x1, float y1, float x2, float y2, float width) {
    glLineWidth(width);
    Vertex verts[2] = {
        {x1, y1, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x2, y2, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]}
    };
    draw_vertices(verts, 2, GL_LINES);
}

void gl_draw_rect_filled(float x, float y, float width, float height) {
    Vertex verts[6] = {
        {x, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x + width, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x + width, y + height, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x + width, y + height, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x, y + height, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]}
    };
    draw_vertices(verts, 6, GL_TRIANGLES);
}

void gl_draw_rect_outline(float x, float y, float width, float height, float line_width) {
    glLineWidth(line_width);
    Vertex verts[5] = {
        {x, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x + width, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x + width, y + height, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x, y + height, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]},
        {x, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]}
    };
    draw_vertices(verts, 5, GL_LINE_STRIP);
}

void gl_draw_circle(float cx, float cy, float radius, int segments) {
    Vertex *verts = (Vertex *)malloc((segments + 2) * sizeof(Vertex));
    verts[0] = (Vertex){cx, cy, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]};
    
    for (int i = 0; i <= segments; i++) {
        float angle = 2.0f * M_PI * i / segments;
        float x = cx + radius * cosf(angle);
        float y = cy + radius * sinf(angle);
        verts[i+1] = (Vertex){x, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]};
    }
    
    draw_vertices(verts, segments + 2, GL_TRIANGLE_FAN);
    free(verts);
}

void gl_draw_circle_outline(float cx, float cy, float radius, float line_width, int segments) {
    glLineWidth(line_width);
    Vertex *verts = (Vertex *)malloc((segments + 1) * sizeof(Vertex));
    
    for (int i = 0; i <= segments; i++) {
        float angle = 2.0f * M_PI * i / segments;
        float x = cx + radius * cosf(angle);
        float y = cy + radius * sinf(angle);
        verts[i] = (Vertex){x, y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]};
    }
    
    draw_vertices(verts, segments + 1, GL_LINE_STRIP);
    free(verts);
}

void gl_draw_polygon(float *points, int num_points, int filled) {
    Vertex *verts = (Vertex *)malloc(num_points * sizeof(Vertex));
    for (int i = 0; i < num_points; i++) {
        verts[i] = (Vertex){points[i*2], points[i*2+1], gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]};
    }
    draw_vertices(verts, num_points, filled ? GL_TRIANGLES : GL_LINE_STRIP);
    free(verts);
}

void gl_draw_polyline(float *points, int num_points, float line_width) {
    glLineWidth(line_width);
    Vertex *verts = (Vertex *)malloc(num_points * sizeof(Vertex));
    for (int i = 0; i < num_points; i++) {
        verts[i] = (Vertex){points[i*2], points[i*2+1], gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]};
    }
    draw_vertices(verts, num_points, GL_LINE_STRIP);
    free(verts);
}

// Generate seed-based pseudo-random value for deterministic asteroid shapes
static float comet_random_jagged(int seed, int index) {
    int x = seed * 73856093 ^ (index * 19349663);
    return (float)((x * 2654435761U) % 1000) / 1000.0f;
}

// Generate random jagged asteroid points for more variation
static void generate_jagged_asteroid_points(double points[][2], int num_points, double radius, int seed) {
    for (int i = 0; i < num_points; i++) {
        double angle = 2.0 * M_PI * i / num_points;
        
        // Base radius with random jagger (use seed for determinism)
        float jagged = 0.6f + 0.4f * comet_random_jagged(seed, i);
        double point_radius = radius * jagged;
        
        // Random angle offset for more irregular shape
        float angle_offset = (comet_random_jagged(seed + 1, i) - 0.5f) * 0.5f;  // ±0.25 rad variation
        
        points[i][0] = point_radius * cos(angle + angle_offset);
        points[i][1] = point_radius * sin(angle + angle_offset);
    }
}

// Helper to draw transformed polygon outline for comets with enhanced tumbling
static void draw_comet_polygon(Comet *c, double points[][2], int num_points, float line_width) {
    if (!c) return;
    
    // Allocate for points + closing point
    Vertex *verts = (Vertex *)malloc((num_points + 1) * sizeof(Vertex));
    
    // PRIMARY rotation (main tumble)
    float angle = c->base_angle + c->rotation * M_PI / 180.0f;
    float cos_a = cosf(angle);
    float sin_a = sinf(angle);
    
    // SECONDARY rotation (tumble in perpendicular direction for more dynamic rotation)
    // This creates the illusion of tumbling/spinning in 3D space
    float secondary_rotation = (c->rotation * 0.7f) * M_PI / 180.0f;
    float cos_sec = cosf(secondary_rotation);
    float sin_sec = sinf(secondary_rotation);
    
    // Transform and add all points
    for (int j = 0; j < num_points; j++) {
        float x = (float)points[j][0];
        float y = (float)points[j][1];
        
        // Apply secondary rotation for tumbling effect (creates 3D-like tumble)
        float x_tumble = x * cos_sec - y * sin_sec;
        float y_tumble = x * sin_sec + y * cos_sec;
        
        // Apply primary rotation
        float rotated_x = (float)(x_tumble * cos_a - y_tumble * sin_a);
        float rotated_y = (float)(x_tumble * sin_a + y_tumble * cos_a);
        
        // Translate to comet position
        rotated_x += (float)c->x;
        rotated_y += (float)c->y;
        
        verts[j] = (Vertex){rotated_x, rotated_y, gl_state.color[0], gl_state.color[1], gl_state.color[2], gl_state.color[3]};
    }
    
    // Close the polygon by repeating first vertex
    verts[num_points] = verts[0];
    
    glLineWidth(line_width);
    // Use GL_LINE_STRIP with num_points+1 to close the polygon
    draw_vertices(verts, num_points + 1, GL_LINE_STRIP);
    free(verts);
}

// ✓ VECTOR-BASED ASTEROIDS (like original Asteroids arcade game)
// Enhanced with varied shapes, tumbling animation, and better destruction particles
void draw_comet_buster_comets_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)width;
    (void)height;
    (void)cr;
    
    for (int i = 0; i < game->comet_count; i++) {
        Comet *c = &game->comets[i];
        
        // Skip inactive (destroyed) comets - DO NOT RENDER THEM
        if (!c->active) continue;
        
        // Set color and line width
        gl_set_color(c->color[0], c->color[1], c->color[2]);
        
        double radius = c->radius;
        
        // Use rotation_speed as deterministic shape seed for variety
        int shape_seed = (int)(c->rotation_speed * 1000) % 997;  // Large prime for good distribution
        int shape_variant = shape_seed % 4;  // 4 variants per size now
        
        if (c->size == COMET_MEGA) {
            // Mega asteroid: 13+ points with high jagger
            int num_points = 13 + (shape_seed % 3);  // 13-15 points
            double points[16][2];
            generate_jagged_asteroid_points(points, num_points, radius, shape_seed);
            draw_comet_polygon(c, points, num_points, 3.5f);
            
        } else if (c->size == COMET_LARGE) {
            // Large asteroid: 10-12 irregular points
            int num_points = 10 + (shape_seed % 3);  // 10-12 points
            double points[12][2];
            generate_jagged_asteroid_points(points, num_points, radius, shape_seed);
            draw_comet_polygon(c, points, num_points, 2.5f);
            
        } else if (c->size == COMET_MEDIUM) {
            // Medium asteroid: 8-9 irregular points
            int num_points = 8 + (shape_seed % 2);  // 8-9 points
            double points[9][2];
            generate_jagged_asteroid_points(points, num_points, radius, shape_seed);
            draw_comet_polygon(c, points, num_points, 2.0f);
            
        } else if (c->size == COMET_SMALL) {
            // Small asteroid: 6-7 points (still varied)
            int num_points = 6 + (shape_seed % 2);  // 6-7 points
            double points[7][2];
            generate_jagged_asteroid_points(points, num_points, radius, shape_seed);
            draw_comet_polygon(c, points, num_points, 1.5f);
        }
    }
}

void draw_comet_buster_gl(Visualizer *visualizer, void *cr) {
    if (!visualizer) return;

    if (!isGLInitialized) {
        gl_init();
        SDL_Log("[Comet Busters] [Comet Busters] Initializing GL Init (should only happen once)");
        isGLInitialized = 1;
    }

    CometBusterGame *game = &visualizer->comet_buster;
    int width = visualizer->width;
    int height = visualizer->height;
    
    gl_setup_2d_projection(width, height);
    
#ifdef ExternalSound
    // Draw splash screen if active
    if (game->splash_screen_active) {
        comet_buster_draw_splash_screen_gl(game, cr, width, height);
        return;  // Don't draw game yet
    }
    
    // Draw finale splash if active (Wave 30 complete screen)
    if (game->finale_splash_active) {
        comet_buster_draw_finale_splash_gl(game, cr, width, height);
        return;  // Don't draw game yet
    }
#endif
    
    // Background is already set in on_realize, no need to draw again
    
    // Draw grid (extended 50 pixels to the right)
    gl_set_color(0.1f, 0.15f, 0.35f);
    glLineWidth(0.5f);
    
    for (int i = 0; i <= width + 50; i += 50) {
        gl_draw_line(i, 0, i, height, 0.5f);
    }
    for (int i = 0; i <= height; i += 50) {
        gl_draw_line(0, i, width + 50, i, 0.5f);
    }
    
    // Draw game elements
    draw_comet_buster_comets_gl(game, cr, width, height);
    draw_comet_buster_bullets_gl(game, cr, width, height);
    draw_comet_buster_enemy_ships_gl(game, cr, width, height);
    draw_comet_buster_ufos_gl(game, cr, width, height);
    
    // Draw boss (either Spawn Queen or regular Death Star)
    if (game->boss_active) {
        if (game->spawn_queen.active && game->spawn_queen.is_spawn_queen) {
            draw_spawn_queen_boss_gl(game, &game->spawn_queen, cr, width, height);
        } else if (game->boss.active) {
            if (game->current_wave % 30 == 5) {
               draw_comet_buster_boss_gl(game, &game->boss, cr, width, height);
           } else if (game->current_wave % 30 == 10) {
               draw_spawn_queen_boss_gl(game, &game->spawn_queen, cr, width, height);
           } else if (game->current_wave % 30 == 15) {
              draw_void_nexus_boss_gl(game, &game->boss, cr, width, height);
           } else if (game->current_wave % 30 == 20) {
              draw_harbinger_boss_gl(game, &game->boss, cr, width, height);
           } else if (game->current_wave % 30 == 25) {
              draw_star_vortex_boss_gl(&game->boss, cr, width, height);
           } else if (game->current_wave % 30 == 0) {
              draw_singularity_boss_gl(game, &game->boss, cr, width, height);
           }
       }
    }
    
    draw_comet_buster_enemy_bullets_gl(game, cr, width, height);
    draw_comet_buster_canisters_gl(game, cr, width, height);
    draw_comet_buster_missile_pickups_gl(game, cr, width, height);
    draw_comet_buster_bomb_pickups_gl(game, cr, width, height);
    draw_comet_buster_missiles_gl(game, cr, width, height);
    draw_comet_buster_bombs_gl(game, cr, width, height);
    draw_comet_buster_particles_gl(game, cr, width, height);
    draw_comet_buster_ship_gl(game, cr, width, height);
    
    // Draw boss explosion effect
    boss_explosion_draw_gl(&game->boss_explosion_effect, cr);
    
    // Draw HUD
    draw_comet_buster_hud_gl(game, cr, width, height);
    
    // Draw game over
    if (game->game_over) {
        draw_comet_buster_game_over_gl(game, cr, width, height);
    }
}

void draw_comet_buster_bullets_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr;
    (void)width;
    (void)height;
    
    for (int i = 0; i < game->bullet_count; i++) {
        Bullet *b = &game->bullets[i];
        if (!b->active) continue;
        
        // Draw bullet as yellow diamond (4 points)
        // Points: (x+size, y), (x, y+size), (x-size, y), (x, y-size)
        double size = 3.0;
        Vertex diamond_verts[5] = {
            {(float)(b->x + size), (float)b->y, 1.0f, 1.0f, 0.0f, 1.0f},     // Right
            {(float)b->x, (float)(b->y + size), 1.0f, 1.0f, 0.0f, 1.0f},    // Bottom
            {(float)(b->x - size), (float)b->y, 1.0f, 1.0f, 0.0f, 1.0f},    // Left
            {(float)b->x, (float)(b->y - size), 1.0f, 1.0f, 0.0f, 1.0f},    // Top
            {(float)(b->x + size), (float)b->y, 1.0f, 1.0f, 0.0f, 1.0f}     // Close back to right
        };
        
        // Draw filled diamond
        gl_set_color(1.0f, 1.0f, 0.0f);
        draw_vertices(diamond_verts, 5, GL_TRIANGLE_FAN);
        
        // Draw bullet trail (classic Asteroids style)
        double trail_length = 5.0;
        double norm_len = sqrt(b->vx * b->vx + b->vy * b->vy);
        if (norm_len > 0.1) {
            double trail_x = b->x - (b->vx / norm_len) * trail_length;
            double trail_y = b->y - (b->vy / norm_len) * trail_length;
            
            gl_set_color_alpha(1.0f, 1.0f, 0.0f, 0.3f);
            glLineWidth(0.5f);
            gl_draw_line((float)trail_x, (float)trail_y, (float)b->x, (float)b->y, 0.5f);
        }
    }
}

void draw_comet_buster_enemy_ships_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr;
    (void)width;
    (void)height;
    
    for (int i = 0; i < game->enemy_ship_count; i++) {
        EnemyShip *ship = &game->enemy_ships[i];
        if (!ship->active) continue;
        
        // Determine color based on ship type
        float ship_r = 0.2f, ship_g = 0.6f, ship_b = 1.0f;  // Default: blue (patrol, type 0)
        
        switch (ship->ship_type) {
            case 1:  // Aggressive red ship
                ship_r = 1.0f; ship_g = 0.0f; ship_b = 0.0f;
                break;
            case 2:  // Hunter green ship
                ship_r = 0.2f; ship_g = 1.0f; ship_b = 0.2f;
                break;
            case 3:  // Sentinel purple ship
                ship_r = 0.8f; ship_g = 0.2f; ship_b = 1.0f;
                break;
            case 4:  // Brown coat elite cyan ship
                ship_r = 0.0f; ship_g = 0.9f; ship_b = 1.0f;
                break;
            case 5:  // Juggernaut gold ship
                ship_r = 1.0f; ship_g = 0.84f; ship_b = 0.0f;
                break;
        }
        
        // Determine size based on ship type
        double ship_size;
        if (ship->ship_type == 5) {
            ship_size = 36.0;  // Juggernaut: 3x
        } else if (ship->ship_type == 4) {
            ship_size = 18.0;  // Brown coat: 1.5x
        } else {
            ship_size = 12.0;  // All others: 1x
        }
        
        // Transform triangle points
        float cos_a = cosf((float)ship->angle);
        float sin_a = sinf((float)ship->angle);
        
        // Triangle points in local coordinates:
        // Front: (ship_size, 0)
        // Back left: (-ship_size, -ship_size/1.5)
        // Back right: (-ship_size, ship_size/1.5)
        double local_points[3][2] = {
            {ship_size, 0},
            {-ship_size, -ship_size / 1.5},
            {-ship_size, ship_size / 1.5}
        };
        
        // Transform to world coordinates
        Vertex ship_verts[4];
        for (int j = 0; j < 3; j++) {
            float x = (float)local_points[j][0];
            float y = (float)local_points[j][1];
            
            // Rotate by ship angle
            float rotated_x = x * cos_a - y * sin_a;
            float rotated_y = x * sin_a + y * cos_a;
            
            // Translate to ship position
            rotated_x += (float)ship->x;
            rotated_y += (float)ship->y;
            
            ship_verts[j] = (Vertex){rotated_x, rotated_y, ship_r, ship_g, ship_b, 1.0f};
        }
        
        // Close the polygon
        ship_verts[3] = ship_verts[0];
        
        // Draw filled triangle
        gl_set_color(ship_r, ship_g, ship_b);
        draw_vertices(ship_verts, 3, GL_TRIANGLE_FAN);
        
        // ========== INTIMIDATING STRIPES ==========
        // Draw diagonal stripes across the ship body for aggressive look
        {
            float stripe_r = fminf(ship_r + 0.3f, 1.0f);
            float stripe_g = fminf(ship_g + 0.3f, 1.0f);
            float stripe_b = fminf(ship_b + 0.3f, 1.0f);
            
            // Calculate stripe positions along the ship body
            int num_stripes = (ship->ship_type == 5) ? 6 : (ship->ship_type == 4) ? 4 : 3;
            
            for (int s = 0; s < num_stripes; s++) {
                // Position along the body (from front to back)
                float stripe_pos = 0.3f - (s * 0.35f / (float)num_stripes);
                
                // Calculate stripe width and angle
                float stripe_width = (ship->ship_type == 5) ? 3.0f : 2.0f;
                float stripe_length = ship_size * 0.8f;
                
                // Create two points for the stripe line (perpendicular to movement)
                double local_x1 = stripe_pos * ship_size;
                double local_y1 = -stripe_length / 4.0;
                double local_x2 = stripe_pos * ship_size;
                double local_y2 = stripe_length / 4.0;
                
                // Transform both points
                float world_x1 = (float)(local_x1 * cos_a - local_y1 * sin_a + ship->x);
                float world_y1 = (float)(local_x1 * sin_a + local_y1 * cos_a + ship->y);
                float world_x2 = (float)(local_x2 * cos_a - local_y2 * sin_a + ship->x);
                float world_y2 = (float)(local_x2 * sin_a + local_y2 * cos_a + ship->y);
                
                // Draw stripe with brighter color
                glLineWidth(stripe_width);
                gl_set_color(stripe_r, stripe_g, stripe_b);
                gl_draw_line(world_x1, world_y1, world_x2, world_y2, stripe_width);
            }
        }
        
        // Draw outline
        glLineWidth(1.5f);
        gl_set_color(ship_r, ship_g, ship_b);
        draw_vertices(ship_verts, 4, GL_LINE_STRIP);
        
        // ========== THRUSTER FLAME EFFECTS ==========
        // Calculate velocity to determine flame intensity
        double velocity = sqrt(ship->vx * ship->vx + ship->vy * ship->vy);
        double flame_intensity = fminf(velocity / 100.0, 1.0);  // Normalize to 0-1
        
        if (flame_intensity > 0.05 || ship->ship_type == 5) {  // Always show flames for Juggernaut
            // Flame ejection point at rear of ship
            double flame_base_local_x = -ship_size * 0.9;
            double flame_base_local_y = 0;
            
            float flame_base_x = (float)(flame_base_local_x * cos_a - flame_base_local_y * sin_a + ship->x);
            float flame_base_y = (float)(flame_base_local_x * sin_a + flame_base_local_y * cos_a + ship->y);
            
            // Calculate flame direction (opposite to velocity direction)
            double flame_dir_x = -ship->vx;
            double flame_dir_y = -ship->vy;
            double flame_dir_len = sqrt(flame_dir_x * flame_dir_x + flame_dir_y * flame_dir_y);
            
            if (flame_dir_len > 0.1) {
                flame_dir_x /= flame_dir_len;
                flame_dir_y /= flame_dir_len;
            } else {
                // Default to pointing backwards along ship angle
                flame_dir_x = -cos_a;
                flame_dir_y = -sin_a;
            }
            
            // Flame base width
            double flame_width = ship_size * 0.6;
            
            // ===== OUTER FLAME (orange/red) =====
            double outer_flame_length = ship_size * 1.2 * flame_intensity;
            double flicker = 0.8 + 0.2 * sin(ship->burner_flicker_timer * 30.0 + i);  // Flicker effect
            
            Vertex outer_flame_verts[4];
            
            // Left side
            double left_x = flame_base_x - flame_dir_y * flame_width;
            double left_y = flame_base_y + flame_dir_x * flame_width;
            outer_flame_verts[0] = (Vertex){(float)left_x, (float)left_y, 1.0f, 0.4f, 0.0f, 1.0f};
            
            // Right side
            double right_x = flame_base_x + flame_dir_y * flame_width;
            double right_y = flame_base_y - flame_dir_x * flame_width;
            outer_flame_verts[1] = (Vertex){(float)right_x, (float)right_y, 1.0f, 0.4f, 0.0f, 1.0f};
            
            // Tip
            double tip_x = flame_base_x + flame_dir_x * outer_flame_length;
            double tip_y = flame_base_y + flame_dir_y * outer_flame_length;
            outer_flame_verts[2] = (Vertex){(float)tip_x, (float)tip_y, 1.0f, 0.2f, 0.0f, (float)flicker * 0.6f};
            
            outer_flame_verts[3] = outer_flame_verts[0];
            
            glLineWidth(2.0f);
            gl_set_color_alpha(1.0f, 0.4f, 0.0f, 0.7f * (float)flame_intensity);
            draw_vertices(outer_flame_verts, 3, GL_TRIANGLE_FAN);
            
            // ===== INNER FLAME (bright yellow) =====
            double inner_flame_length = outer_flame_length * 0.6;
            
            Vertex inner_flame_verts[4];
            
            // Left side (narrower)
            double inner_left_x = flame_base_x - flame_dir_y * flame_width * 0.4;
            double inner_left_y = flame_base_y + flame_dir_x * flame_width * 0.4;
            inner_flame_verts[0] = (Vertex){(float)inner_left_x, (float)inner_left_y, 1.0f, 1.0f, 0.3f, 1.0f};
            
            // Right side (narrower)
            double inner_right_x = flame_base_x + flame_dir_y * flame_width * 0.4;
            double inner_right_y = flame_base_y - flame_dir_x * flame_width * 0.4;
            inner_flame_verts[1] = (Vertex){(float)inner_right_x, (float)inner_right_y, 1.0f, 1.0f, 0.3f, 1.0f};
            
            // Inner tip
            double inner_tip_x = flame_base_x + flame_dir_x * inner_flame_length;
            double inner_tip_y = flame_base_y + flame_dir_y * inner_flame_length;
            inner_flame_verts[2] = (Vertex){(float)inner_tip_x, (float)inner_tip_y, 1.0f, 1.0f, 0.6f, (float)flicker * 0.9f};
            
            inner_flame_verts[3] = inner_flame_verts[0];
            
            gl_set_color_alpha(1.0f, 1.0f, 0.3f, 0.8f * (float)flame_intensity);
            draw_vertices(inner_flame_verts, 3, GL_TRIANGLE_FAN);
        }
        
        // Draw Juggernaut health bar (for type 5 only)
        if (ship->ship_type == 5) {
            double bar_width = 60.0;
            double bar_height = 8.0;
            double bar_x = ship->x - bar_width / 2.0;
            double bar_y = ship->y + 50.0;
            
            // Background bar
            gl_set_color(0.3f, 0.3f, 0.3f);
            gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
            
            // Outline
            glLineWidth(1.0f);
            gl_set_color(0.3f, 0.3f, 0.3f);
            gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
            
            // Health fill (green to yellow to red)
            double health_ratio = (double)ship->health / 10.0;
            if (health_ratio < 0.0) health_ratio = 0.0;
            if (health_ratio > 1.0) health_ratio = 1.0;
            
            float bar_r, bar_g, bar_b;
            if (health_ratio > 0.5) {
                // Green to yellow (high health)
                bar_r = (1.0f - (float)health_ratio) * 2.0f;
                bar_g = 1.0f;
                bar_b = 0.0f;
            } else {
                // Yellow to red (low health)
                bar_r = 1.0f;
                bar_g = (float)health_ratio * 2.0f;
                bar_b = 0.0f;
            }
            
            gl_set_color(bar_r, bar_g, bar_b);
            double fill_width = (bar_width - 2.0) * health_ratio;
            gl_draw_rect_filled((float)(bar_x + 1.0), (float)(bar_y + 1.0), (float)fill_width, (float)(bar_height - 2.0));
        }
        
        // ========== SHIELD CIRCLE ==========
        if (ship->shield_health > 0) {
            // Determine shield color based on ship type
            float shield_r = 0.2f, shield_g = 0.6f, shield_b = 1.0f;
            float shield_alpha = 0.5f;
            
            switch (ship->ship_type) {
                case 1:  // Red ship shield: orange/red
                    shield_r = 1.0f; shield_g = 0.5f; shield_b = 0.0f;
                    break;
                case 2:  // Green ship shield: bright green
                    shield_r = 0.5f; shield_g = 1.0f; shield_b = 0.5f;
                    break;
                case 3:  // Sentinel purple shield: bright purple
                    shield_r = 0.8f; shield_g = 0.4f; shield_b = 1.0f;
                    break;
                case 4:  // Brown coat cyan shield - bright cyan
                    shield_r = 0.2f; shield_g = 0.9f; shield_b = 1.0f;
                    shield_alpha = 0.6f;  // Brighter for brown coat
                    break;
                case 5:  // Juggernaut gold shield - golden glow
                    shield_r = 1.0f; shield_g = 0.9f; shield_b = 0.2f;
                    break;
            }
            
            // Determine shield radius based on ship type
            double shield_radius;
            if (ship->ship_type == 5) {
                shield_radius = 50.0;  // Larger shield for juggernaut
            } else if (ship->ship_type == 4) {
                shield_radius = 24.0;  // Slightly larger for brown coat
            } else {
                shield_radius = 22.0;  // Standard shield radius
            }
            
            // Draw shield circle
            gl_set_color_alpha(shield_r, shield_g, shield_b, shield_alpha);
            gl_draw_circle_outline((float)ship->x, (float)ship->y, (float)shield_radius, 2.0f, 24);
            
            // Draw shield impact flash
            if (ship->shield_impact_timer > 0) {
                float flash_alpha = (float)(ship->shield_impact_timer / 0.2);
                if (flash_alpha > 1.0f) flash_alpha = 1.0f;
                
                double impact_x = 22.0 * cos(ship->shield_impact_angle);
                double impact_y = 22.0 * sin(ship->shield_impact_angle);
                
                // Bright white flash circle
                gl_set_color_alpha(1.0f, 1.0f, 1.0f, flash_alpha * 0.8f);
                gl_draw_circle((float)(ship->x + impact_x), (float)(ship->y + impact_y), 4.0f, 12);
                
                // Expanding rings
                double ring_radius = 6.0 + (1.0 - flash_alpha) * 10.0;
                gl_set_color_alpha(1.0f, 1.0f, 1.0f, flash_alpha * 0.4f);
                gl_draw_circle_outline((float)(ship->x + impact_x), (float)(ship->y + impact_y), (float)ring_radius, 1.0f, 16);
            }
        }
    }
}

void draw_comet_buster_ufos_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr;
    (void)width;
    (void)height;
    
    for (int i = 0; i < game->ufo_count; i++) {
        UFO *ufo = &game->ufos[i];
        if (!ufo->active) continue;
        
        // Set color based on damage state
        float ufo_r = 0.0f, ufo_g = 1.0f, ufo_b = 1.0f;  // Cyan
        if (ufo->damage_flash_timer > 0) {
            ufo_r = 1.0f; ufo_g = 1.0f; ufo_b = 1.0f;  // White when hit
        }
        
        // UFO dimensions
        double dome_width = 40.0;
        double dome_height = 20.0;
        double porthole_radius = 3.5;
        double porthole_spacing = 14.0;
        double fin_width = 5.0;
        double fin_height = 6.0;
        
        // ========== DOME (Top semicircle) ==========
        gl_set_color(ufo_r, ufo_g, ufo_b);
        glLineWidth(1.5f);
        
        // Draw top dome - semicircle
        int dome_segments = 20;
        Vertex dome_verts[21];
        for (int j = 0; j <= dome_segments; j++) {
            double angle = M_PI + (j * M_PI / dome_segments);  // From PI to 2*PI (top half)
            float x = (float)(ufo->x + (dome_width / 2.0) * cos(angle));
            float y = (float)(ufo->y + (dome_width / 2.0) * sin(angle));
            dome_verts[j] = (Vertex){x, y, ufo_r, ufo_g, ufo_b, 1.0f};
        }
        draw_vertices(dome_verts, dome_segments + 1, GL_LINE_STRIP);
        
        // ========== FLAT LINE (where dome meets body) ==========
        gl_draw_line((float)(ufo->x - dome_width / 2.0), (float)ufo->y,
                     (float)(ufo->x + dome_width / 2.0), (float)ufo->y, 1.5f);
        
        // ========== THREE PORTHOLES ==========
        // Left porthole
        gl_set_color(ufo_r, ufo_g, ufo_b);
        gl_draw_circle_outline((float)(ufo->x - porthole_spacing), 
                              (float)(ufo->y + dome_height / 2.0), 
                              (float)porthole_radius, 1.5f, 12);
        
        // Center porthole
        gl_draw_circle_outline((float)ufo->x, 
                              (float)(ufo->y + dome_height / 2.0), 
                              (float)porthole_radius, 1.5f, 12);
        
        // Right porthole
        gl_draw_circle_outline((float)(ufo->x + porthole_spacing), 
                              (float)(ufo->y + dome_height / 2.0), 
                              (float)porthole_radius, 1.5f, 12);
        
        // ========== FINS ==========
        // Left fin
        gl_draw_rect_outline((float)(ufo->x - porthole_spacing - fin_width / 2.0),
                            (float)(ufo->y + dome_height / 2.0),
                            (float)fin_width, (float)fin_height, 1.5f);
        
        // Right fin
        gl_draw_rect_outline((float)(ufo->x + porthole_spacing - fin_width / 2.0),
                            (float)(ufo->y + dome_height / 2.0),
                            (float)fin_width, (float)fin_height, 1.5f);
        
        // ========== HEALTH INDICATOR DOTS ==========
        if (ufo->health < ufo->max_health) {
            for (int h = 0; h < ufo->max_health; h++) {
                if (h < ufo->health) {
                    gl_set_color(0.0f, 1.0f, 1.0f);  // Cyan for healthy
                } else {
                    gl_set_color(0.3f, 0.3f, 0.3f);  // Dark gray for missing
                }
                
                double dot_x = ufo->x - 10.0 + h * 10.0;
                double dot_y = ufo->y - dome_height - 8.0;
                gl_draw_circle((float)dot_x, (float)dot_y, 2.0f, 12);
            }
        }
    }
}

void draw_comet_buster_enemy_bullets_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr;
    (void)width;
    (void)height;
    for (int i = 0; i < game->enemy_bullet_count; i++) {
        Bullet *b = &game->enemy_bullets[i];
        if (!b->active) continue;
        gl_set_color(0.0f, 1.0f, 1.0f);  // Cyan - matches Cairo version
        gl_draw_circle(b->x, b->y, 3.0f, 8);
    }
}

void draw_comet_buster_canisters_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr;
    (void)width;
    (void)height;
    
    for (int i = 0; i < game->canister_count; i++) {
        Canister *c = &game->canisters[i];
        if (!c->active) continue;
        
        // Alpha based on remaining lifetime (fade out near end)
        float alpha = 1.0f;
        if (c->lifetime < 2.0) {
            alpha = (float)(c->lifetime / 2.0);
        }
        
        // Draw shield shape as a simple circle for now (easier to debug)
        // Darker cyan fill
        gl_set_color_alpha(0.0f, 0.6f, 0.8f, alpha * 0.3f);
        gl_draw_circle(c->x, c->y, 12.0f, 24);
        
        // Bright cyan outline
        gl_set_color_alpha(0.0f, 1.0f, 1.0f, alpha);
        gl_draw_circle_outline(c->x, c->y, 12.0f, 2.0f, 24);
        
        // Draw medical cross in center
        gl_set_color_alpha(0.0f, 1.0f, 1.0f, alpha);
        float cross_size = 5.0f;
        gl_draw_line(c->x - cross_size, (float)c->y, c->x + cross_size, (float)c->y, 1.5f);
        gl_draw_line((float)c->x, c->y - cross_size, (float)c->x, c->y + cross_size, 1.5f);
    }
}

void draw_comet_buster_missile_pickups_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr; (void)width; (void)height;
    
    for (int i = 0; i < game->missile_pickup_count; i++) {
        MissilePickup *pickup = &game->missile_pickups[i];
        if (!pickup->active) continue;
        
        // Alpha fade out in last 2 seconds
        float alpha = 1.0f;
        if (pickup->lifetime < 2.0) {
            alpha = (float)(pickup->lifetime / 2.0);
        }
        
        double size = 10.0;
        
        // Draw X shape (orange lines)
        gl_set_color_alpha(1.0f, 0.65f, 0.0f, alpha);
        gl_draw_line((float)(pickup->x - size), (float)(pickup->y - size), 
                     (float)(pickup->x + size), (float)(pickup->y + size), 2.5f);
        gl_draw_line((float)(pickup->x + size), (float)(pickup->y - size), 
                     (float)(pickup->x - size), (float)(pickup->y + size), 2.5f);
        
        // Draw circle outline (orange)
        gl_draw_circle_outline(pickup->x, pickup->y, size + 4.0, 1.5f, 24);
        
        // Draw yellow filled circle in center
        gl_set_color_alpha(1.0f, 1.0f, 0.0f, alpha);
        gl_draw_circle(pickup->x, pickup->y, 2.5f, 12);
    }
}

void draw_comet_buster_bomb_pickups_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr; (void)width; (void)height;
    
    for (int i = 0; i < game->bomb_pickup_count; i++) {
        BombPickup *p = &game->bomb_pickups[i];
        if (!p->active) continue;
        
        // Alpha fade out in last 2 seconds
        float alpha = 1.0f;
        if (p->lifetime < 2.0) {
            alpha = (float)(p->lifetime / 2.0);
        }
        
        // Draw main bomb circle (orange/yellow)
        gl_set_color_alpha(1.0f, 0.7f, 0.0f, alpha);
        gl_draw_circle(p->x, p->y, 12.0f, 24);
        
        // Draw fuse (line sticking out from top)
        gl_set_color_alpha(0.8f, 0.4f, 0.2f, alpha);
        gl_draw_line((float)p->x, (float)p->y - 12.0f, (float)p->x, (float)p->y - 22.0f, 1.5f);
    }
}

void draw_comet_buster_missiles_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr;
    (void)width;
    (void)height;
    
    // Color scheme for each missile type
    // Type 0: CYAN - Target furthest comet
    // Type 1: RED - Target ships and boss
    // Type 2: GREEN - Target closest comets
    // Type 3: MAGENTA - Target comets ~400px away
    // Type 4: ORANGE - Target comets 200-600px away
    
    for (int i = 0; i < game->missile_count; i++) {
        Missile *missile = &game->missiles[i];
        if (!missile->active) continue;
        
        // Calculate alpha fade based on lifetime
        float alpha = 1.0f;
        if (missile->lifetime < 0.5) {
            alpha = (float)(missile->lifetime / 0.5);
        }
        
        // Determine fill color based on missile type
        float fill_r = 1.0f, fill_g = 1.0f, fill_b = 0.2f;  // Default yellow
        float stroke_r = 1.0f, stroke_g = 0.8f, stroke_b = 0.0f;  // Default orange
        
        switch (missile->missile_type) {
            case 0:  // Furthest comet - CYAN
                fill_r = 0.2f; fill_g = 1.0f; fill_b = 1.0f;
                stroke_r = 0.0f; stroke_g = 0.8f; stroke_b = 1.0f;
                break;
            case 1:  // Ships and boss - RED
                fill_r = 1.0f; fill_g = 0.2f; fill_b = 0.2f;
                stroke_r = 1.0f; stroke_g = 0.0f; stroke_b = 0.0f;
                break;
            case 2:  // Closest comets - GREEN
                fill_r = 0.2f; fill_g = 1.0f; fill_b = 0.2f;
                stroke_r = 0.0f; stroke_g = 0.8f; stroke_b = 0.0f;
                break;
            case 3:  // Comets ~400px away - MAGENTA
                fill_r = 1.0f; fill_g = 0.2f; fill_b = 1.0f;
                stroke_r = 0.8f; stroke_g = 0.0f; stroke_b = 0.8f;
                break;
            case 4:  // Comets 200-600px away - ORANGE
                fill_r = 1.0f; fill_g = 0.6f; fill_b = 0.0f;
                stroke_r = 1.0f; stroke_g = 0.4f; stroke_b = 0.0f;
                break;
        }
        
        float cos_a = cosf((float)missile->angle);
        float sin_a = sinf((float)missile->angle);
        
        // ===== DRAW EXHAUST FLAMES (behind the missile) =====
        // All flames are red
        float flame_r = 1.0f, flame_g = 0.2f, flame_b = 0.0f;  // Red flame
        
        // Draw exhaust flame (two triangles for width)
        float flame_length = 8.0f;
        float flame_width = 2.5f;
        
        // Left flame
        float flame_points_left[6] = {
            -6.0f,  -flame_width,    // Base left
            -6.0f,  flame_width,     // Base right
            -6.0f - flame_length, 0.0f  // Tip
        };
        
        // Right flame
        float flame_points_right[6] = {
            -6.0f,  flame_width,     // Base left
            -6.0f,  -flame_width,    // Base right
            -6.0f - flame_length, 0.0f  // Tip
        };
        
        Vertex flame_verts[3];
        for (int j = 0; j < 3; j++) {
            float x = flame_points_left[j*2];
            float y = flame_points_left[j*2+1];
            float rotated_x = x * cos_a - y * sin_a + (float)missile->x;
            float rotated_y = x * sin_a + y * cos_a + (float)missile->y;
            flame_verts[j] = (Vertex){rotated_x, rotated_y, flame_r, flame_g, flame_b, alpha * 0.6f};
        }
        gl_set_color_alpha(flame_r, flame_g, flame_b, alpha * 0.6f);
        draw_vertices(flame_verts, 3, GL_TRIANGLES);
        
        // ===== DRAW MISSILE BODY =====
        // Missile shape (pointed nose with body and thruster fins):
        // Nose cone, body, and two small thruster fins
        float points[20] = {
            10.0f,  0.0f,      // Pointed nose (0)
            6.0f,   2.0f,      // Upper body (1)
            4.0f,   3.0f,      // Upper thruster start (2)
            0.0f,   3.5f,      // Upper thruster wing (3)
            -4.0f,  1.5f,      // Upper back (4)
            -6.0f,  0.0f,      // Back center (5)
            -4.0f, -1.5f,      // Lower back (6)
            0.0f,  -3.5f,      // Lower thruster wing (7)
            4.0f,  -3.0f,      // Lower thruster start (8)
            6.0f,  -2.0f       // Lower body (9)
        };
        
        Vertex verts[10];
        for (int j = 0; j < 10; j++) {
            float x = points[j*2];
            float y = points[j*2+1];
            
            // Rotate point
            float rotated_x = x * cos_a - y * sin_a;
            float rotated_y = x * sin_a + y * cos_a;
            
            // Translate to missile position
            rotated_x += (float)missile->x;
            rotated_y += (float)missile->y;
            
            verts[j] = (Vertex){rotated_x, rotated_y, fill_r, fill_g, fill_b, alpha};
        }
        
        // Draw filled missile body
        gl_set_color_alpha(fill_r, fill_g, fill_b, alpha);
        draw_vertices(verts, 10, GL_TRIANGLE_FAN);
        
        // Draw missile outline for definition
        gl_set_color_alpha(stroke_r, stroke_g, stroke_b, alpha);
        glLineWidth(1.5f);
        
        // Create outline vertices (repeat first to close)
        Vertex outline_verts[11];
        for (int j = 0; j < 10; j++) {
            outline_verts[j] = verts[j];
        }
        outline_verts[10] = verts[0];  // Close the shape
        
        draw_vertices(outline_verts, 11, GL_LINE_STRIP);
        
        // ===== DRAW SMALL THRUSTER NOZZLES =====
        // Two small thruster nozzles on the sides (red flame colored)
        
        gl_set_color_alpha(flame_r, flame_g, flame_b, alpha);
        
        // Upper thruster nozzle (small circle at wing position)
        float thruster_size = 1.5f;
        float nozzle_points[6] = {
            0.0f,   3.5f,
            thruster_size,   3.0f,
            -thruster_size,  3.0f
        };
        
        Vertex thruster_verts[3];
        for (int j = 0; j < 3; j++) {
            float x = nozzle_points[j*2];
            float y = nozzle_points[j*2+1];
            float rotated_x = x * cos_a - y * sin_a + (float)missile->x;
            float rotated_y = x * sin_a + y * cos_a + (float)missile->y;
            thruster_verts[j] = (Vertex){rotated_x, rotated_y, flame_r, flame_g, flame_b, alpha};
        }
        draw_vertices(thruster_verts, 3, GL_TRIANGLES);
        
        // Lower thruster nozzle
        float nozzle_points_lower[6] = {
            0.0f,   -3.5f,
            -thruster_size,  -3.0f,
            thruster_size,   -3.0f
        };
        
        for (int j = 0; j < 3; j++) {
            float x = nozzle_points_lower[j*2];
            float y = nozzle_points_lower[j*2+1];
            float rotated_x = x * cos_a - y * sin_a + (float)missile->x;
            float rotated_y = x * sin_a + y * cos_a + (float)missile->y;
            thruster_verts[j] = (Vertex){rotated_x, rotated_y, flame_r, flame_g, flame_b, alpha};
        }
        draw_vertices(thruster_verts, 3, GL_TRIANGLES);
    }
}

void draw_comet_buster_bombs_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr; (void)width; (void)height;
    for (int i = 0; i < game->bomb_count; i++) {
        Bomb *bomb = &game->bombs[i];
        if (!bomb->active) continue;
        
        if (!bomb->detonated) {
            // Pulsing effect based on time left
            double pulse = 1.0 - (bomb->lifetime / bomb->max_lifetime) * 0.3;  // Pulses as countdown happens
            
            // Main bomb body - orange circle with pulsing
            gl_set_color_alpha((float)(1.0 * pulse), 0.6f, 0.0f, 1.0f);
            gl_draw_circle(bomb->x, bomb->y, 15.0f, 24);
            
            // Outline - yellow
            gl_set_color(1.0f, 0.8f, 0.0f);
            gl_draw_circle_outline(bomb->x, bomb->y, 15.0f, 2.0f, 24);
            
            // Fuse - brown line sticking up
            gl_set_color(0.7f, 0.3f, 0.1f);
            gl_draw_line(bomb->x, bomb->y - 15.0f, bomb->x, bomb->y - 28.0f, 2.0f);
            
            // Spark at fuse - yellow circle
            gl_set_color(1.0f, 1.0f, 0.2f);
            gl_draw_circle(bomb->x, bomb->y - 28.0f, 3.0f, 12);
            
            // Countdown text - white number
            gl_set_color(1.0f, 1.0f, 1.0f);
            int countdown = (int)(bomb->lifetime + 1);
            if (countdown < 1) countdown = 1;
            
            char text[8];
            snprintf(text, sizeof(text), "%d", countdown);
            
            // Draw countdown text centered on bomb
            gl_draw_text_simple(text, (int)bomb->x - 3, (int)bomb->y - 2, 12);
        } else {
            // Draw explosion wave
            // Expanding circle with fading opacity
            double wave_progress = bomb->wave_radius / bomb->wave_max_radius;
            double opacity = 1.0 - wave_progress;  // Fades out as it expands
            
            gl_set_color_alpha(1.0f, 0.5f, 0.0f, (float)opacity);
            gl_draw_circle_outline(bomb->x, bomb->y, bomb->wave_radius, 2.0f, 24);
        }
    }
}

void draw_comet_buster_particles_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    for (int i = 0; i < game->particle_count; i++) {
        Particle *p = &game->particles[i];
        if (!p->active) continue;
        double alpha = p->lifetime / p->max_lifetime;
        gl_set_color_alpha(p->color[0], p->color[1], p->color[2], alpha);
        gl_draw_circle(p->x, p->y, p->size, 6);
    }
}

void draw_comet_buster_ship_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)cr;
    (void)width;
    (void)height;
    
    // ========== MAIN SHIP BODY ==========
    double ship_size = 12.0;
    float cos_a = cosf((float)game->ship_angle);
    float sin_a = sinf((float)game->ship_angle);
    
    // Ship triangle points (in local coordinates):
    // (12,0), (-12,-12), (-3.6,0), (-12,12), close back to (12,0)
    double local_points[4][2] = {
        {ship_size, 0},           // Front point
        {-ship_size, -ship_size}, // Top left
        {-ship_size * 0.3, 0},    // Side notch
        {-ship_size, ship_size}   // Bottom left
    };
    
    // Transform points to world coordinates
    Vertex ship_verts[5];
    for (int i = 0; i < 4; i++) {
        float x = (float)local_points[i][0];
        float y = (float)local_points[i][1];
        
        // Rotate by ship angle
        float rotated_x = x * cos_a - y * sin_a;
        float rotated_y = x * sin_a + y * cos_a;
        
        // Translate to ship position
        rotated_x += (float)game->ship_x;
        rotated_y += (float)game->ship_y;
        
        // Determine color with invulnerability flash
        float r = 0.0f, g = 1.0f, b = 0.0f;
        float a = 1.0f;
        
        if (game->invulnerability_time > 0) {
            float flash = sinf((float)game->invulnerability_time * 10.0f) * 0.5f + 0.5f;
            a = flash;
        }
        
        ship_verts[i] = (Vertex){rotated_x, rotated_y, r, g, b, a};
    }
    
    // Close the polygon by repeating first vertex (like cairo_close_path)
    ship_verts[4] = ship_verts[0];
    
    // Draw outline only - NO FILL (just stroke like Cairo version)
    gl_set_color(0.0f, 1.0f, 0.0f);
    glLineWidth(2.0f);
    draw_vertices(ship_verts, 5, GL_LINE_STRIP);
    
    // ========== MUZZLE FLASH ==========
    if (game->muzzle_flash_timer > 0) {
        float alpha = (float)(game->muzzle_flash_timer / 0.1);
        if (alpha > 1.0f) alpha = 1.0f;
        
        // Muzzle flash triangle: (12,0), (12+20,-5), (12+20,5), close
        double muzzle_local[3][2] = {
            {ship_size, 0},
            {ship_size + 20.0, -5.0},
            {ship_size + 20.0, 5.0}
        };
        
        Vertex muzzle_verts[3];
        for (int i = 0; i < 3; i++) {
            float x = (float)muzzle_local[i][0];
            float y = (float)muzzle_local[i][1];
            
            float rotated_x = x * cos_a - y * sin_a;
            float rotated_y = x * sin_a + y * cos_a;
            
            rotated_x += (float)game->ship_x;
            rotated_y += (float)game->ship_y;
            
            muzzle_verts[i] = (Vertex){rotated_x, rotated_y, 1.0f, 1.0f, 0.0f, alpha};
        }
        
        gl_set_color_alpha(1.0f, 1.0f, 0.0f, alpha);
        draw_vertices(muzzle_verts, 3, GL_TRIANGLE_FAN);
    }
    
    // ========== BURNER/THRUSTER EFFECT ==========
    if (game->burner_intensity > 0.01) {
        // Flicker effect
        float flicker = 0.7f + 0.3f * sinf((float)game->burner_intensity * 20.0f);
        float effective_intensity = (float)game->burner_intensity * flicker;
        
        // Calculate speed for length multiplier
        double speed = sqrt(game->ship_vx * game->ship_vx + game->ship_vy * game->ship_vy);
        double length_mult = 1.0 + (speed / 150.0) * 0.5;
        
        double flame_length = 30.0 * effective_intensity * length_mult;
        double flame_width = 8.0 * effective_intensity;
        
        // Main burner flame points (pointing backward from back of ship)
        // Ship back is at x = -ship_size (-12), flame extends from there
        double burner_local[4][2] = {
            {-ship_size, -flame_width},                          // Top at back of ship
            {-ship_size - flame_length, -flame_width * 0.3},    // Top tip of flame
            {-ship_size - flame_length, flame_width * 0.3},     // Bottom tip of flame
            {-ship_size, flame_width}                            // Bottom at back of ship
        };
        
        Vertex burner_verts[4];
        for (int i = 0; i < 4; i++) {
            float x = (float)burner_local[i][0];
            float y = (float)burner_local[i][1];
            
            float rotated_x = x * cos_a - y * sin_a;
            float rotated_y = x * sin_a + y * cos_a;
            
            rotated_x += (float)game->ship_x;
            rotated_y += (float)game->ship_y;
            
            // Flame color gradient: yellow -> orange -> red
            float color_r = 1.0f;
            float color_g = 0.7f * (1.0f - (float)i / 3.0f);  // Fade orange
            float color_b = 0.0f;
            
            burner_verts[i] = (Vertex){rotated_x, rotated_y, color_r, color_g, color_b, effective_intensity * 0.7f};
        }
        
        gl_set_color_alpha(1.0f, 0.7f, 0.0f, effective_intensity * 0.7f);
        draw_vertices(burner_verts, 4, GL_TRIANGLE_FAN);
    }
    
    // ========== SHIELD CIRCLE ==========
    if (game->shield_health > 0) {
        float shield_alpha = (float)game->shield_health / (float)game->max_shield_health;
        
        // Shield color: cyan when healthy, orange when medium, red when critical
        float shield_r = 0.0f, shield_g = 1.0f, shield_b = 1.0f;
        if (game->shield_health >= 2) {
            shield_r = 0.0f; shield_g = 1.0f; shield_b = 1.0f;  // Cyan
        } else if (game->shield_health >= 1) {
            shield_r = 1.0f; shield_g = 0.8f; shield_b = 0.0f;  // Orange
        } else {
            shield_r = 1.0f; shield_g = 0.3f; shield_b = 0.3f;  // Red
        }
        
        // Draw shield circle
        gl_set_color_alpha(shield_r, shield_g, shield_b, shield_alpha * 0.6f);
        gl_draw_circle_outline((float)game->ship_x, (float)game->ship_y, 28.0f, 2.5f, 24);
        
        // Draw shield segment pips
        glLineWidth(1.5f);
        double segment_angle = (2.0 * M_PI) / game->max_shield_health;
        
        for (int i = 0; i < game->shield_health; i++) {
            double angle = (i * segment_angle) - (M_PI / 2.0);
            double x1 = 24.0 * cos(angle);
            double y1 = 24.0 * sin(angle);
            double x2 = 32.0 * cos(angle);
            double y2 = 32.0 * sin(angle);
            
            gl_draw_line((float)(game->ship_x + x1), (float)(game->ship_y + y1),
                        (float)(game->ship_x + x2), (float)(game->ship_y + y2),
                        1.5f);
        }
        
        // Draw impact flash
        if (game->shield_impact_timer > 0) {
            float flash_alpha = (float)(game->shield_impact_timer / 0.2);
            if (flash_alpha > 1.0f) flash_alpha = 1.0f;
            
            double impact_x = 28.0 * cos(game->shield_impact_angle);
            double impact_y = 28.0 * sin(game->shield_impact_angle);
            
            // Bright white flash
            gl_set_color_alpha(1.0f, 1.0f, 1.0f, flash_alpha * 0.8f);
            gl_draw_circle((float)(game->ship_x + impact_x), (float)(game->ship_y + impact_y), 5.0f, 12);
            
            // Expanding rings
            double ring_radius = 8.0 + (1.0 - flash_alpha) * 12.0;
            gl_set_color_alpha(1.0f, 1.0f, 1.0f, flash_alpha * 0.4f);
            gl_draw_circle_outline((float)(game->ship_x + impact_x), (float)(game->ship_y + impact_y), 
                                  (float)ring_radius, 1.0f, 16);
        }
    }
}

void draw_comet_buster_boss_gl(CometBusterGame *game, BossShip *boss, void *cr, int width, int height) {
    if (!boss || !boss->active) return;
    (void)cr; (void)width; (void)height;
    
    double body_radius = 35.0;
    
    // Main body - large dark gray circle
    gl_set_color(0.3f, 0.3f, 0.4f);
    gl_draw_circle(boss->x, boss->y, (float)body_radius, 32);
    
    // Highlight if taking damage
    if (boss->damage_flash_timer > 0) {
        gl_set_color_alpha(1.0f, 0.5f, 0.5f, 0.7f);
        gl_draw_circle(boss->x, boss->y, (float)body_radius, 32);
    }
    
    // Outer ring - metallic look
    gl_set_color_alpha(0.6f, 0.6f, 0.7f, 0.8f);
    gl_draw_circle_outline(boss->x, boss->y, (float)body_radius, 2.5f, 32);
    
    // Draw rotating pattern on the boss (8 lines radiating)
    gl_set_color(0.8f, 0.8f, 0.9f);
    for (int i = 0; i < 8; i++) {
        double angle = (i * 2.0 * M_PI / 8.0);
        double x1 = cos(angle) * 20.0;
        double y1 = sin(angle) * 20.0;
        double x2 = cos(angle) * 30.0;
        double y2 = sin(angle) * 30.0;
        
        gl_draw_line((float)(boss->x + x1), (float)(boss->y + y1),
                     (float)(boss->x + x2), (float)(boss->y + y2), 1.5f);
    }
    
    // Core/center glow - red pulsing
    double core_radius = 8.0;
    gl_set_color(1.0f, 0.2f, 0.2f);
    gl_draw_circle(boss->x, boss->y, (float)core_radius, 16);
    
    // Inner glow around core
    gl_set_color_alpha(1.0f, 0.3f, 0.3f, 0.6f);
    gl_draw_circle_outline(boss->x, boss->y, (float)(core_radius + 3.0), 1.5f, 16);
    
    // Draw health bar above boss
    double bar_width = 80.0;
    double bar_height = 6.0;
    double bar_x = boss->x - bar_width / 2.0;
    double bar_y = boss->y - 50.0;
    
    // Background (gray)
    gl_set_color(0.3f, 0.3f, 0.3f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
    
    // Health fill (red)
    double health_ratio = (double)boss->health / boss->max_health;
    gl_set_color(1.0f, 0.2f, 0.2f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)(bar_width * health_ratio), (float)bar_height);
    
    // Border (white)
    gl_set_color(1.0f, 1.0f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
    
    // Draw shield if active
    if (boss->shield_active && boss->shield_health > 0) {
        double shield_radius = 50.0;
        double shield_ratio = (double)boss->shield_health / boss->max_shield_health;
        
        // Outer shield glow (pulsing)
        float pulse_alpha = 0.3f + 0.1f * (float)sin(boss->shield_impact_timer * 10.0);
        gl_set_color_alpha(0.0f, 0.8f, 1.0f, pulse_alpha);
        gl_draw_circle(boss->x, boss->y, (float)shield_radius, 32);
        
        // Shield outline
        gl_set_color_alpha(0.0f, 1.0f, 1.0f, 0.8f);
        gl_draw_circle_outline(boss->x, boss->y, (float)shield_radius, 2.0f, 32);
        
        // Shield segments
        gl_set_color(0.0f, 1.0f, 1.0f);
        int num_segments = 12;
        for (int i = 0; i < num_segments; i++) {
            if (i < (int)(num_segments * shield_ratio)) {
                double angle = (i * 2.0 * M_PI / num_segments);
                double x1 = cos(angle) * (shield_radius - 3.0);
                double y1 = sin(angle) * (shield_radius - 3.0);
                double x2 = cos(angle) * (shield_radius + 3.0);
                double y2 = sin(angle) * (shield_radius + 3.0);
                
                gl_draw_line((float)(boss->x + x1), (float)(boss->y + y1),
                             (float)(boss->x + x2), (float)(boss->y + y2), 1.5f);
            }
        }
    }
    
    // Draw phase indicator
    const char *phase_text = "";
    float phase_r = 1.0f, phase_g = 1.0f, phase_b = 0.5f;
    
    if (boss->phase == 0) {
        phase_text = phase_normal_text[game->current_language];
        phase_r = 1.0f; phase_g = 1.0f; phase_b = 0.5f;  // Yellow
    } else if (boss->phase == 1) {
        phase_text = phase_shielded_text[game->current_language];
        phase_r = 0.0f; phase_g = 1.0f; phase_b = 1.0f;  // Cyan
    } else {
        phase_text = phase_enraged_text[game->current_language];
        phase_r = 1.0f; phase_g = 0.2f; phase_b = 0.2f;  // Red
    }

    
    gl_set_color(phase_r, phase_g, phase_b);
    gl_draw_text_simple(phase_text, (int)(boss->x - 25), (int)(boss->y - 25), 10);
}

void draw_spawn_queen_boss_gl(CometBusterGame *game, SpawnQueenBoss *queen, void *cr, int width, int height) {
    if (!queen || !queen->active) return;
    (void)cr; (void)width; (void)height;
    
    double major_axis = 70.0;
    double minor_axis = 45.0;
    int segments = 32;
    
    // Build vertices for the elliptical body
    Vertex body_verts[32];
    for (int i = 0; i < segments; i++) {
        double angle = 2.0 * M_PI * i / segments;
        float cos_a = (float)cos(angle);
        float sin_a = (float)sin(angle);
        
        // Rotate the point around the boss center
        float cos_rot = (float)cos(queen->rotation * M_PI / 180.0);
        float sin_rot = (float)sin(queen->rotation * M_PI / 180.0);
        
        float x = cos_a * (float)major_axis;
        float y = sin_a * (float)minor_axis;
        
        // Apply rotation
        float rx = x * cos_rot - y * sin_rot;
        float ry = x * sin_rot + y * cos_rot;
        
        body_verts[i] = {(float)queen->x + rx, (float)queen->y + ry, 0.7f, 0.3f, 0.8f, 1.0f};
    }
    
    // Draw filled magenta body
    draw_vertices(body_verts, segments, GL_TRIANGLE_FAN);
    
    // Draw rotating darker oval pattern on the body (shows rotation)
    gl_set_color_alpha(0.4f, 0.1f, 0.5f, 0.6f);
    double pattern_major = 50.0;
    double pattern_minor = 20.0;
    Vertex pattern_verts[32];
    for (int i = 0; i < segments; i++) {
        double angle = 2.0 * M_PI * i / segments;
        float cos_a = (float)cos(angle);
        float sin_a = (float)sin(angle);
        
        // Rotate the pattern point
        float cos_rot = (float)cos(queen->rotation * M_PI / 180.0);
        float sin_rot = (float)sin(queen->rotation * M_PI / 180.0);
        
        float x = cos_a * (float)pattern_major;
        float y = sin_a * (float)pattern_minor;
        
        // Apply rotation
        float rx = x * cos_rot - y * sin_rot;
        float ry = x * sin_rot + y * cos_rot;
        
        pattern_verts[i] = {(float)queen->x + rx, (float)queen->y + ry, 0.4f, 0.1f, 0.5f, 0.6f};
    }
    draw_vertices(pattern_verts, segments, GL_TRIANGLE_FAN);
    
    // Draw cyan outline ring (elliptical, matching body rotation)
    gl_set_color_alpha(0.0f, 1.0f, 1.0f, 0.7f);
    Vertex outline_verts[32];
    for (int i = 0; i < segments; i++) {
        double angle = 2.0 * M_PI * i / segments;
        float cos_a = (float)cos(angle);
        float sin_a = (float)sin(angle);
        
        // Rotate the outline point
        float cos_rot = (float)cos(queen->rotation * M_PI / 180.0);
        float sin_rot = (float)sin(queen->rotation * M_PI / 180.0);
        
        float x = cos_a * (float)major_axis;
        float y = sin_a * (float)minor_axis;
        
        // Apply rotation
        float rx = x * cos_rot - y * sin_rot;
        float ry = x * sin_rot + y * cos_rot;
        
        outline_verts[i] = {(float)queen->x + rx, (float)queen->y + ry, 0.0f, 1.0f, 1.0f, 0.7f};
    }
    glLineWidth(2.5f);
    draw_vertices(outline_verts, segments, GL_LINE_LOOP);
    glLineWidth(1.0f);
    
    // Draw light cyan glow background (elliptical, matching body rotation)
    gl_set_color_alpha(0.0f, 0.8f, 1.0f, 0.2f);
    double glow_major = major_axis + 10.0;
    double glow_minor = minor_axis + 10.0;
    Vertex glow_verts[32];
    for (int i = 0; i < segments; i++) {
        double angle = 2.0 * M_PI * i / segments;
        float cos_a = (float)cos(angle);
        float sin_a = (float)sin(angle);
        
        // Rotate the glow point
        float cos_rot = (float)cos(queen->rotation * M_PI / 180.0);
        float sin_rot = (float)sin(queen->rotation * M_PI / 180.0);
        
        float x = cos_a * (float)glow_major;
        float y = sin_a * (float)glow_minor;
        
        // Apply rotation
        float rx = x * cos_rot - y * sin_rot;
        float ry = x * sin_rot + y * cos_rot;
        
        glow_verts[i] = {(float)queen->x + rx, (float)queen->y + ry, 0.0f, 0.8f, 1.0f, 0.2f};
    }
    draw_vertices(glow_verts, segments, GL_TRIANGLE_FAN);
    
    // Spawn ports - 6 around equator with pulsing glow
    double port_radius = 6.0;
    double port_orbit = 50.0;
    
    // Determine port colors based on phase
    float port_r, port_g, port_b;
    if (queen->phase == 0) {
        port_r = 1.0f; port_g = 0.2f; port_b = 0.2f;  // Red
    } else if (queen->phase == 1) {
        port_r = 1.0f; port_g = 0.5f; port_b = 0.8f;  // Magenta
    } else {
        port_r = 0.8f; port_g = 0.3f; port_b = 1.0f;  // Purple
    }
    
    // Pulsing glow intensity
    double glow_intensity = 0.5 + 0.5 * sin(queen->spawn_particle_timer * 5.0);
    
    for (int i = 0; i < 6; i++) {
        double angle = 2.0 * M_PI * i / 6.0;
        double px = cos(angle) * port_orbit;
        double py = sin(angle) * port_orbit * 0.6;
        
        // Outer glow
        gl_set_color_alpha(port_r, port_g, port_b, (float)(glow_intensity * 0.5));
        gl_draw_circle(queen->x + px, queen->y + py, (float)(port_radius + 4.0), 16);
        
        // Port center (brighter)
        gl_set_color(port_r, port_g, port_b);
        gl_draw_circle(queen->x + px, queen->y + py, (float)port_radius, 16);
    }
    
    // Damage flash overlay (elliptical, matching body rotation)
    if (queen->damage_flash_timer > 0) {
        gl_set_color_alpha(1.0f, 0.5f, 0.5f, 0.4f);
        Vertex damage_verts[32];
        for (int i = 0; i < segments; i++) {
            double angle = 2.0 * M_PI * i / segments;
            float cos_a = (float)cos(angle);
            float sin_a = (float)sin(angle);
            
            // Rotate the damage overlay point
            float cos_rot = (float)cos(queen->rotation * M_PI / 180.0);
            float sin_rot = (float)sin(queen->rotation * M_PI / 180.0);
            
            float x = cos_a * (float)major_axis;
            float y = sin_a * (float)minor_axis;
            
            // Apply rotation
            float rx = x * cos_rot - y * sin_rot;
            float ry = x * sin_rot + y * cos_rot;
            
            damage_verts[i] = {(float)queen->x + rx, (float)queen->y + ry, 1.0f, 0.5f, 0.5f, 0.4f};
        }
        draw_vertices(damage_verts, segments, GL_TRIANGLE_FAN);
    }
    
    // Red pulsing core
    double core_size = 12.0 + 3.0 * sin(queen->phase_timer * 3.0);
    gl_set_color(1.0f, 0.2f, 0.2f);
    gl_draw_circle(queen->x, queen->y, (float)core_size, 16);
    
    // Health bar above boss
    double bar_width = 100.0;
    double bar_height = 8.0;
    double bar_x = queen->x - bar_width / 2.0;
    double bar_y = queen->y - 70.0;
    
    // Health bar - Background
    gl_set_color(0.2f, 0.2f, 0.2f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
    
    // Health fill
    double health_ratio = (double)queen->health / queen->max_health;
    gl_set_color(1.0f, 0.2f, 0.2f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)(bar_width * health_ratio), (float)bar_height);
    
    // Health bar border
    gl_set_color(1.0f, 1.0f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
    
    // Shield bar below health bar
    double shield_y = bar_y + bar_height + 2.0;
    
    // Shield bar - Background
    gl_set_color(0.2f, 0.2f, 0.2f);
    gl_draw_rect_filled((float)bar_x, (float)shield_y, (float)bar_width, (float)bar_height);
    
    // Shield fill (cyan)
    double shield_ratio = (double)queen->shield_health / queen->max_shield_health;
    gl_set_color(0.0f, 1.0f, 1.0f);
    gl_draw_rect_filled((float)bar_x, (float)shield_y, (float)(bar_width * shield_ratio), (float)bar_height);
    
    // Shield bar border
    gl_set_color(1.0f, 1.0f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)shield_y, (float)bar_width, (float)bar_height, 1.0f);
    
    // Phase indicator text
    const char *phase_text = "";
    float text_r = 1.0f, text_g = 0.5f, text_b = 0.0f;

    if (queen->phase == 0) {
        phase_text = queen_phase_recruiting_text[game->current_language];
        text_r = 1.0f; text_g = 0.5f; text_b = 0.0f;  // Orange
    } else if (queen->phase == 1) {
        phase_text = queen_phase_aggressive_text[game->current_language];
        text_r = 1.0f; text_g = 1.0f; text_b = 0.0f;  // Yellow
    } else {
        phase_text = queen_phase_desperate_text[game->current_language];
        text_r = 1.0f; text_g = 0.0f; text_b = 0.0f;  // Red
    }

    
    gl_set_color(text_r, text_g, text_b);
    gl_draw_text_simple(phase_text, (int)(queen->x - 35), (int)(queen->y + 75), 11);
}

void draw_void_nexus_boss_gl(CometBusterGame *game, BossShip *boss, void *cr, int width, int height) {
    if (!boss || !boss->active) return;
    (void)cr; (void)width; (void)height;
    
    if (boss->fragment_count == 0) {
        // Draw main body - crystalline octagon with rotating rings
        
        // Outer energy ring (pulsing circle)
        double pulse = 0.5 + 0.3 * sin(boss->rotation * M_PI / 180.0 * 0.1);
        gl_set_color_alpha(0.2f, 0.8f, 1.0f, (float)pulse);
        gl_draw_circle(boss->x, boss->y, (float)(40.0 + pulse * 5.0), 32);
        
        // Main crystalline body - octagon (8 sides)
        gl_set_color(0.3f, 0.7f, 1.0f);  // Bright cyan
        const int oct_sides = 8;
        Vertex oct_verts[8];
        double oct_radius = 30.0;
        
        for (int i = 0; i < oct_sides; i++) {
            double angle = (i * 2.0 * M_PI / oct_sides) + (boss->rotation * M_PI / 180.0);
            double x = cos(angle) * oct_radius;
            double y = sin(angle) * oct_radius;
            oct_verts[i] = {(float)(boss->x + x), (float)(boss->y + y), 0.3f, 0.7f, 1.0f, 1.0f};
        }
        draw_vertices(oct_verts, oct_sides, GL_TRIANGLE_FAN);
        
        // Draw octagon outline
        gl_set_color(0.3f, 0.7f, 1.0f);
        glLineWidth(2.0f);
        draw_vertices(oct_verts, oct_sides, GL_LINE_LOOP);
        glLineWidth(1.0f);
        
        // Core nucleus (bright white)
        gl_set_color(1.0f, 1.0f, 1.0f);
        gl_draw_circle(boss->x, boss->y, 6.0f, 16);
        
        // Damage flash overlay
        if (boss->damage_flash_timer > 0) {
            gl_set_color_alpha(1.0f, 0.5f, 0.5f, 0.6f);
            gl_draw_circle(boss->x, boss->y, 35.0f, 32);
        }
        
    } else {
        // Draw fragments - smaller crystals (hexagons)
        for (int i = 0; i < boss->fragment_count; i++) {
            double frag_x = boss->fragment_positions[i][0];
            double frag_y = boss->fragment_positions[i][1];
            
            double frag_pulse = 0.3 + 0.2 * sin((boss->rotation + i * 45) * M_PI / 180.0 * 0.1);
            
            // Fragment glow (pulsing circle)
            gl_set_color_alpha(0.0f, 1.0f, 1.0f, (float)frag_pulse);
            gl_draw_circle(frag_x, frag_y, (float)(25.0 + frag_pulse * 3.0), 16);
            
            // Fragment body - hexagon (6 sides)
            gl_set_color(0.2f, 0.9f, 1.0f);
            const int hex_sides = 6;
            Vertex hex_verts[6];
            double hex_radius = 20.0;
            
            for (int j = 0; j < hex_sides; j++) {
                double angle = j * 2.0 * M_PI / hex_sides;
                double x = cos(angle) * hex_radius;
                double y = sin(angle) * hex_radius;
                hex_verts[j] = {(float)(frag_x + x), (float)(frag_y + y), 0.2f, 0.9f, 1.0f, 1.0f};
            }
            draw_vertices(hex_verts, hex_sides, GL_TRIANGLE_FAN);
            
            // Draw hexagon outline
            gl_set_color(0.2f, 0.9f, 1.0f);
            glLineWidth(1.5f);
            draw_vertices(hex_verts, hex_sides, GL_LINE_LOOP);
            glLineWidth(1.0f);
            
            // Fragment core (white circle)
            gl_set_color(1.0f, 1.0f, 1.0f);
            gl_draw_circle(frag_x, frag_y, 4.0f, 16);
            
            // Fragment health indicator (red text)
            if (boss->fragment_health[i] > 0) {
                gl_set_color(1.0f, 0.0f, 0.0f);
                char health_text[8];
                snprintf(health_text, sizeof(health_text), "%d", boss->fragment_health[i]);
                gl_draw_text_simple(health_text, (int)frag_x - 5, (int)frag_y + 3, 8);
            }
        }
    }
    
    // Draw health bar
    double bar_width = 100.0;
    double bar_height = 8.0;
    double bar_x = boss->x - bar_width / 2.0;
    double bar_y = boss->y - 55.0;
    
    // Background
    gl_set_color(0.2f, 0.2f, 0.2f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
    
    // Health fill (cyan)
    double health_percent = (double)boss->health / boss->max_health;
    if (health_percent < 0) health_percent = 0;
    
    gl_set_color(0.0f, 1.0f, 1.0f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)(bar_width * health_percent), (float)bar_height);
    
    // Border
    gl_set_color(1.0f, 1.0f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
}

void draw_harbinger_boss_gl(CometBusterGame *game, BossShip *boss, void *cr, int width, int height) {
    if (!boss || !boss->active) return;
    (void)cr; (void)width; (void)height;
    
    // Main body - dark cosmic entity with 6 points
    double core_size = 35.0;
    
    // Outer aura (pulsing based on phase)
    double aura_pulse = 0.3 + 0.4 * sin(boss->rotation * M_PI / 180.0 * 0.05);
    if (boss->phase == 2) {
        aura_pulse = 0.7;  // Brighter in frenzy
    }
    
    gl_set_color_alpha((float)(0.4 + aura_pulse * 0.3), 0.0f, (float)(0.8 + aura_pulse * 0.2), 0.6f);
    gl_draw_circle(boss->x, boss->y, (float)(core_size + 15), 32);
    
    // Core body - dark purple with 6 angular points
    gl_set_color(0.3f, 0.0f, 0.7f);
    const int hex_points = 6;
    Vertex hex_verts[6];
    
    for (int i = 0; i < hex_points; i++) {
        double angle = (i * 2.0 * M_PI / hex_points) + (boss->rotation * M_PI / 180.0);
        double x = cos(angle) * core_size;
        double y = sin(angle) * core_size;
        hex_verts[i] = {(float)(boss->x + x), (float)(boss->y + y), 0.3f, 0.0f, 0.7f, 1.0f};
    }
    
    draw_vertices(hex_verts, hex_points, GL_TRIANGLE_FAN);
    
    // Magenta outline
    gl_set_color(1.0f, 0.3f, 1.0f);
    glLineWidth(2.0f);
    draw_vertices(hex_verts, hex_points, GL_LINE_LOOP);
    glLineWidth(1.0f);
    
    // Inner core (yellow center)
    gl_set_color(1.0f, 1.0f, 0.0f);
    gl_draw_circle(boss->x, boss->y, 8.0f, 16);
    
    // Draw laser charging indicator (phase 1)
    if (boss->phase == 1) {
        gl_set_color(1.0f, 0.5f, 1.0f);  // Light magenta
        glLineWidth(2.0f);
        
        for (int i = 0; i < 4; i++) {
            double laser_angle = boss->laser_angle * M_PI / 180.0 + (i * M_PI / 2.0);
            double x = cos(laser_angle) * 40.0;
            double y = sin(laser_angle) * 40.0;
            
            // Draw line from center outward
            Vertex laser_verts[2] = {
                {(float)boss->x, (float)boss->y, 1.0f, 0.5f, 1.0f, 1.0f},
                {(float)(boss->x + x), (float)(boss->y + y), 1.0f, 0.5f, 1.0f, 1.0f}
            };
            draw_vertices(laser_verts, 2, GL_LINES);
        }
        glLineWidth(1.0f);
    }
    
    // Gravity well effect (phase 2 - visual ripples)
    if (boss->phase == 2 && boss->gravity_well_strength > 0) {
        gl_set_color_alpha(0.0f, 1.0f, 0.8f, 0.3f);
        glLineWidth(1.5f);
        double ripple_size = 20.0 + 10.0 * sin(boss->rotation * M_PI / 180.0 * 0.1);
        
        Vertex ripple_verts[32];
        for (int i = 0; i < 32; i++) {
            double angle = 2.0 * M_PI * i / 32;
            double x = cos(angle) * ripple_size;
            double y = sin(angle) * ripple_size;
            ripple_verts[i] = {(float)(boss->x + x), (float)(boss->y + y), 0.0f, 1.0f, 0.8f, 0.3f};
        }
        draw_vertices(ripple_verts, 32, GL_LINE_LOOP);
        glLineWidth(1.0f);
    }
    
    // Damage flash overlay
    if (boss->damage_flash_timer > 0) {
        gl_set_color_alpha(1.0f, 0.2f, 0.2f, 0.6f);
        gl_draw_circle(boss->x, boss->y, (float)core_size, 32);
    }
    
    // Draw health bar
    double bar_width = 100.0;
    double bar_height = 8.0;
    double bar_x = boss->x - bar_width / 2.0;
    double bar_y = boss->y - 55.0;
    
    // Background
    gl_set_color(0.2f, 0.2f, 0.2f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
    
    // Health fill
    double health_percent = (double)boss->health / boss->max_health;
    if (health_percent < 0) health_percent = 0;
    
    gl_set_color(1.0f, 0.0f, 1.0f);  // Magenta
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)(bar_width * health_percent), (float)bar_height);
    
    // Border
    gl_set_color(1.0f, 1.0f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
}

void draw_star_vortex_boss_gl(BossShip *boss, void *cr, int width, int height) {
    if (!boss || !boss->active) return;
    (void)cr; (void)width; (void)height;
    
    // Draw a 6-pointed star with phase-based colors
    int num_points = 6;
    double outer_radius = 50.0;
    double inner_radius = 25.0;
    
    // Star color (shifts based on phase)
    float r = 1.0f, g = 0.6f, b = 0.0f;  // Orange by default
    if (boss->phase == 1) {
        r = 1.0f; g = 0.3f; b = 0.3f;  // Red for Phase 1
    } else if (boss->phase == 2) {
        r = 1.0f; g = 1.0f; b = 0.0f;  // Yellow for Phase 2
    }
    
    // Draw the star shape with alternating inner/outer points
    const int star_vertices = num_points * 2;
    Vertex star_verts[12];
    
    for (int i = 0; i < star_vertices; i++) {
        double angle = (i * M_PI / num_points) + (boss->rotation * M_PI / 180.0);
        double radius = (i % 2 == 0) ? outer_radius : inner_radius;
        double x = cos(angle) * radius;
        double y = sin(angle) * radius;
        star_verts[i] = {(float)(boss->x + x), (float)(boss->y + y), r, g, b, 1.0f};
    }
    
    // Fill star
    draw_vertices(star_verts, star_vertices, GL_TRIANGLE_FAN);
    
    // Outline (darker shade)
    gl_set_color(r * 0.5f, g * 0.5f, b * 0.5f);
    glLineWidth(2.0f);
    draw_vertices(star_verts, star_vertices, GL_LINE_LOOP);
    glLineWidth(1.0f);
    
    // Damage flash (white highlight)
    if (boss->damage_flash_timer > 0) {
        gl_set_color_alpha(1.0f, 1.0f, 1.0f, (float)boss->damage_flash_timer);
        gl_draw_circle(boss->x, boss->y, (float)(outer_radius * 1.2), 32);
    }
    
    // Shield visualization (if active)
    if (boss->shield_active && boss->shield_health > 0) {
        double shield_ratio = (double)boss->shield_health / boss->max_shield_health;
        gl_set_color_alpha(0.2f, 0.8f, 1.0f, (float)(shield_ratio * 0.6));
        glLineWidth(3.0f);
        
        Vertex shield_verts[32];
        for (int i = 0; i < 32; i++) {
            double angle = 2.0 * M_PI * i / 32;
            double x = cos(angle) * (outer_radius + 10.0);
            double y = sin(angle) * (outer_radius + 10.0);
            shield_verts[i] = {(float)(boss->x + x), (float)(boss->y + y), 0.2f, 0.8f, 1.0f, (float)(shield_ratio * 0.6)};
        }
        draw_vertices(shield_verts, 32, GL_LINE_LOOP);
        glLineWidth(1.0f);
    }
    
    // Draw health bar
    double bar_width = 60.0;
    double bar_height = 8.0;
    double bar_x = boss->x - bar_width / 2.0;
    double bar_y = boss->y - 50.0;
    
    // Background
    gl_set_color_alpha(0.2f, 0.2f, 0.2f, 0.8f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
    
    // Health fill (green)
    double health_ratio = (double)boss->health / boss->max_health;
    gl_set_color(0.0f, 1.0f, 0.0f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)(bar_width * health_ratio), (float)bar_height);
    
    // Border
    gl_set_color(1.0f, 1.0f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
}

void draw_singularity_boss_gl(CometBusterGame *game, BossShip *boss, void *cr, int width, int height) {
    if (!boss || !boss->active) return;
    (void)cr; (void)width; (void)height;
    
    // Determine phase for visual effects
    int phase = boss->phase;
    
    // Main black hole body (grows larger in later phases)
    double core_radius = 60.0;
    if (phase >= 2) core_radius = 80.0;
    
    // Dark center
    gl_set_color(0.1f, 0.05f, 0.15f);
    gl_draw_circle(boss->x, boss->y, (float)core_radius, 32);
    
    // Outer event horizon glow (cyan, pulsing)
    double glow_intensity = 0.2 + 0.3 * sin(boss->rotation * M_PI / 180.0 * 0.1);
    gl_set_color_alpha(0.2f, 0.8f, 1.0f, (float)glow_intensity);
    glLineWidth(3.0f);
    
    Vertex event_horizon[32];
    for (int i = 0; i < 32; i++) {
        double angle = 2.0 * M_PI * i / 32;
        double x = cos(angle) * (core_radius + 15);
        double y = sin(angle) * (core_radius + 15);
        event_horizon[i] = {(float)(boss->x + x), (float)(boss->y + y), 0.2f, 0.8f, 1.0f, (float)glow_intensity};
    }
    draw_vertices(event_horizon, 32, GL_LINE_LOOP);
    glLineWidth(1.0f);
    
    // Inner event horizon rings (3 concentric rings)
    for (int ring = 1; ring <= 3; ring++) {
        double ring_radius = core_radius - (ring * 8);
        double ring_intensity = 0.3 - ring * 0.08;
        
        gl_set_color_alpha(0.2f, 0.8f, 1.0f, (float)ring_intensity);
        glLineWidth(1.5f);
        
        Vertex ring_verts[32];
        for (int i = 0; i < 32; i++) {
            double angle = 2.0 * M_PI * i / 32;
            double x = cos(angle) * ring_radius;
            double y = sin(angle) * ring_radius;
            ring_verts[i] = {(float)(boss->x + x), (float)(boss->y + y), 0.2f, 0.8f, 1.0f, (float)ring_intensity};
        }
        draw_vertices(ring_verts, 32, GL_LINE_LOOP);
    }
    glLineWidth(1.0f);
    
    // Damage flash overlay
    if (boss->damage_flash_timer > 0) {
        gl_set_color_alpha(1.0f, 0.5f, 0.5f, (float)boss->damage_flash_timer);
        gl_draw_circle(boss->x, boss->y, (float)(core_radius + 20), 32);
    }
    
    // Draw orbiting satellites
    // NOTE: These are visual elements only - they do NOT cause collision damage
    // They orbit the Singularity boss and are purely for visual feedback of the boss's status
    for (int i = 0; i < boss->fragment_count; i++) {
        double angle = (i * 360.0 / boss->fragment_count + boss->rotation) * M_PI / 180.0;
        double orbit_radius = 120.0;
        double sat_x = cos(angle) * orbit_radius;
        double sat_y = sin(angle) * orbit_radius;
        
        // Satellite glow
        gl_set_color_alpha(0.0f, 1.0f, 1.0f, 0.5f);
        gl_draw_circle(boss->x + sat_x, boss->y + sat_y, 12.0f, 16);
        
        // Satellite core
        gl_set_color(0.3f, 1.0f, 1.0f);
        gl_draw_circle(boss->x + sat_x, boss->y + sat_y, 8.0f, 16);
    }
    
    // Draw health bar
    double bar_width = 140.0;
    double bar_height = 12.0;
    double bar_x = boss->x - bar_width / 2.0;
    double bar_y = boss->y - 80.0;
    
    // Background
    gl_set_color(0.1f, 0.05f, 0.1f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
    
    // Health fill (cyan gradient effect)
    double health_percent = (double)boss->health / boss->max_health;
    if (health_percent < 0) health_percent = 0;
    
    gl_set_color(0.0f, 1.0f, 1.0f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)(bar_width * health_percent), (float)bar_height);
    
    // Border
    gl_set_color(0.5f, 0.5f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
}

void draw_comet_buster_hud_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game) return;
    (void)height;   // Suppress unused parameter warning
    
    char text[256];
    
    // --- TOP LEFT SECTION ---
    // Score (with multiplier indicator)
    gl_set_color(1.0f, 1.0f, 1.0f);
    sprintf(text, "%s %d (x%.1f)", score_label_text[game->current_language], game->score, game->score_multiplier);
    gl_draw_text_simple(text, 20, 30, 18);
    
    // Lives
    sprintf(text, "%s %d", lives_label_text[game->current_language], game->ship_lives);
    gl_draw_text_simple(text, 20, 55, 18);
    
    // Shield status
    sprintf(text, "%s %d/%d", shield_label_text[game->current_language], game->shield_health, game->max_shield_health);
    if (game->shield_health <= 0) {
        gl_set_color(1.0f, 0.3f, 0.3f);  // Red when no shield
    } else if (game->shield_health == 1) {
        gl_set_color(1.0f, 0.8f, 0.0f);  // Orange when low
    } else {
        gl_set_color(0.0f, 1.0f, 1.0f);  // Cyan when healthy
    }
    gl_draw_text_simple(text, 20, 105, 18);
    gl_set_color(1.0f, 1.0f, 1.0f);  // Reset to white
    
    // --- TOP RIGHT SECTION ---
    // Wave
    gl_set_color(1.0f, 1.0f, 1.0f);
    snprintf(text, sizeof(text), HUD_WAVE_LABEL[game->current_language], game->current_wave);
    gl_draw_text_simple(text, width - 180, 30, 18);
    
    // Asteroids remaining
    snprintf(text, sizeof(text), HUD_WAVE_LABEL[game->current_language], game->current_wave);

    gl_draw_text_simple(text, width - 280, 55, 18);
    
    // Wave progress info (only show if wave is incomplete)
    if (game->wave_complete_timer > 0) {  // Comet count <= 0 should never happen but I had it happen to me once so I put it here.
        sprintf(text, "%s %.1fs", next_wave_in_text[game->current_language], game->wave_complete_timer);
        gl_set_color(1.0f, 1.0f, 0.0f);
        gl_draw_text_simple(text, width / 2 - 160, height / 2 - 50, 18);
        gl_set_color(1.0f, 1.0f, 1.0f);
    } else if (game->comet_count > 0) {
        int expected_count = comet_buster_get_wave_comet_count(game->current_wave);
        sprintf(text, "%s %d/%d", destroyed_label_text[game->current_language], expected_count - game->comet_count, expected_count);
        gl_set_color(1.0f, 1.0f, 1.0f);
        gl_draw_text_simple(text, width - 280, 75, 12);
    }
    
    // --- FLOATING TEXT POPUPS ---
    gl_set_color(1.0f, 1.0f, 1.0f);
    for (int i = 0; i < game->floating_text_count; i++) {
        FloatingText *ft = &game->floating_texts[i];
        if (ft->active) {
            // Calculate fade (alpha) based on remaining lifetime
            float alpha = (float)(ft->lifetime / ft->max_lifetime);
            
            // Set color with fade
            gl_set_color_alpha((float)ft->color[0], (float)ft->color[1], (float)ft->color[2], alpha);
            
            // Draw text
            gl_draw_text_simple(ft->text, (int)ft->x - 30, (int)ft->y, 16);
        }
    }
    gl_set_color(1.0f, 1.0f, 1.0f);  // Reset to white
    
    // --- BOTTOM LEFT SECTION ---
    // Energy bar
    gl_set_color(1.0f, 1.0f, 1.0f);
    sprintf(text, "%s %.0f%%", energy_label_text[game->current_language], game->energy_amount);    
    
    // Color based on fuel level
    if (game->energy_amount < 20) {
        gl_set_color(1.0f, 0.2f, 0.2f);  // Red - critical
    } else if (game->energy_amount < 50) {
        gl_set_color(1.0f, 1.0f, 0.0f);  // Yellow - low
    } else {
        gl_set_color(0.2f, 1.0f, 0.2f);  // Green - good
    }
    
    gl_draw_text_simple(text, 20, height - 40, 14);
    
    // Draw fuel bar (visual indicator)
    double bar_width = 150;
    double bar_height = 12;
    double bar_x = 20;
    double bar_y = height - 25;
    
    // Background (dark)
    gl_set_color(0.2f, 0.2f, 0.2f);
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height);
    
    // Fuel level (colored)
    double fuel_percent = game->energy_amount / game->max_energy;
    if (fuel_percent > 0.5) {
        gl_set_color(0.2f, 1.0f, 0.2f);  // Green
    } else if (fuel_percent > 0.2) {
        gl_set_color(1.0f, 1.0f, 0.0f);  // Yellow
    } else {
        gl_set_color(1.0f, 0.2f, 0.2f);  // Red
    }
    gl_draw_rect_filled((float)bar_x, (float)bar_y, (float)(bar_width * fuel_percent), (float)bar_height);
    
    // Border
    gl_set_color(1.0f, 1.0f, 1.0f);
    gl_draw_rect_outline((float)bar_x, (float)bar_y, (float)bar_width, (float)bar_height, 1.0f);
    
    // --- MISSILES DISPLAY ---
    // Missile ammo display (bottom left, above Energy)
    if (game->missile_ammo > 0 || game->using_missiles) {
        gl_set_color(1.0f, 0.8f, 0.0f);  // Yellow/orange
        char missile_text[32];
        sprintf(missile_text, "%s %d", missiles_label_text[game->current_language], game->missile_ammo);        
        
        gl_draw_text_simple(missile_text, 20, height - 110, 14);
        
        // Draw missile bar
        double missile_bar_width = 150;
        double missile_bar_height = 12;
        double missile_bar_x = 20;
        double missile_bar_y = height - 95;
        
        // Background
        gl_set_color(0.2f, 0.2f, 0.2f);
        gl_draw_rect_filled((float)missile_bar_x, (float)missile_bar_y, (float)missile_bar_width, (float)missile_bar_height);
        
        // Missile bar (assume max 100 for display, each pickup adds 20)
        double missile_percent = (game->missile_ammo > 100) ? 1.0 : (game->missile_ammo / 100.0);
        gl_set_color(1.0f, 0.8f, 0.0f);  // Yellow
        gl_draw_rect_filled((float)missile_bar_x, (float)missile_bar_y, (float)(missile_bar_width * missile_percent), (float)missile_bar_height);
        
        // Border
        gl_set_color(1.0f, 1.0f, 1.0f);
        gl_draw_rect_outline((float)missile_bar_x, (float)missile_bar_y, (float)missile_bar_width, (float)missile_bar_height, 1.0f);
    }
    
    // --- BOMBS DISPLAY ---
    // Bomb ammo display
    if (game->bomb_ammo > 0 || game->bomb_count > 0) {
        gl_set_color(1.0f, 0.6f, 0.0f);  // Orange for bombs
        char bomb_text[32];
        sprintf(bomb_text, "%s %d", bombs_label_text[game->current_language], game->bomb_ammo);
        
        gl_draw_text_simple(bomb_text, 20, height - 65, 14);
        
        // Show active bombs
        if (game->bomb_count > 0) {
            gl_set_color(1.0f, 1.0f, 0.0f);  // Yellow for active
            char active_text[32];
            sprintf(active_text, "%s %d", armed_label_text[game->current_language], game->bomb_count);
            gl_draw_text_simple(active_text, 20, height - 50, 12);
        }
        
        // Draw bomb bar
        double bomb_bar_width = 150;
        double bomb_bar_height = 12;
        double bomb_bar_x = 20;
        double bomb_bar_y = game->bomb_count > 0 ? (height - 35) : (height - 50);
        
        // Background
        gl_set_color(0.2f, 0.2f, 0.2f);
        gl_draw_rect_filled((float)bomb_bar_x, (float)bomb_bar_y, (float)bomb_bar_width, (float)bomb_bar_height);
        
        // Bomb bar
        double bomb_percent = (game->bomb_ammo > 10) ? 1.0 : (game->bomb_ammo / 10.0);
        gl_set_color(1.0f, 0.6f, 0.0f);  // Orange
        gl_draw_rect_filled((float)bomb_bar_x, (float)bomb_bar_y, (float)(bomb_bar_width * bomb_percent), (float)bomb_bar_height);
        
        // Border
        gl_set_color(1.0f, 1.0f, 1.0f);
        gl_draw_rect_outline((float)bomb_bar_x, (float)bomb_bar_y, (float)bomb_bar_width, (float)bomb_bar_height, 1.0f);
    }
}

void draw_comet_buster_game_over_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game || !game->game_over) return;
    gl_set_color_alpha(0.0f, 0.0f, 0.0f, 0.7f);
    gl_draw_rect_filled(0.0f, 0.0f, width, height);
    gl_set_color(1.0f, 0.0f, 0.0f);
    gl_draw_rect_outline(width / 2.0f - 50.0f, height / 2.0f - 30.0f, 100.0f, 60.0f, 2.0f);
}

void boss_explosion_draw_gl(BossExplosion *explosion, void *cr) {
    if (!explosion) return;
    for (int i = 0; i < explosion->particle_count; i++) {
        BossExplosionParticle *p = &explosion->particles[i];
        if (!p->active) continue;
        gl_set_color_alpha(p->color[0], p->color[1], p->color[2], p->glow_intensity);
        gl_draw_circle(p->x, p->y, 3.0f, 12);
    }
}



// ============================================================================
// COMPLETE LOCALIZED OPENGL SPLASH SCREEN FUNCTIONS
// Replace your existing GL functions with these
// ============================================================================

void comet_buster_draw_splash_screen_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game || !game->splash_screen_active) return;
    
    // Draw background (dark space)
    gl_set_color(0.04f, 0.06f, 0.15f);
    gl_draw_rect_filled(0.0f, 0.0f, (float)width, (float)height);
    
    // Draw grid (extended 50 pixels further to the right)
    gl_set_color(0.1f, 0.15f, 0.35f);
    for (int i = 0; i <= width + 50; i += 50) {
        gl_draw_line((float)i, 0.0f, (float)i, (float)height, 0.5f);
    }
    for (int i = 0; i <= height; i += 50) {
        gl_draw_line(0.0f, (float)i, (float)(width + 50), (float)i, 0.5f);
    }
    
    // Draw game elements in background
    draw_comet_buster_comets_gl(game, cr, width, height);
    draw_comet_buster_enemy_ships_gl(game, cr, width, height);
    draw_comet_buster_enemy_bullets_gl(game, cr, width, height);
    draw_comet_buster_particles_gl(game, cr, width, height);
    
    // Draw boss if active
    if (game->boss_active) {
        draw_comet_buster_boss_gl(game, &game->boss, cr, width, height);
    }
    
    // Dim the background with overlay for text visibility
    gl_set_color_alpha(0.0f, 0.0f, 0.0f, 0.3f);
    gl_draw_rect_filled(0.0f, 0.0f, (float)width, (float)height);
    
    // ===== OPENING CRAWL PHASE =====
    // Duration: approximately 0-38 seconds
    double scroll_speed = 1.0;  // seconds per line
    
    if (game->splash_timer < 38.0) {
        // GET LANGUAGE-SPECIFIC ARRAYS
        const char **crawl_lines = get_opening_crawl_for_language(game->current_language);
        int num_crawl_lines = get_num_crawl_lines_for_language(game->current_language);
        
        gl_set_color(1.0f, 0.95f, 0.0f);
        
        // Approximate line height (monospace font)
        float line_height = 24.0f * 1.8f;
        
        // Calculate which lines should be visible
        double current_line_offset = (game->splash_timer / scroll_speed);
        double fractional_offset = fmod(game->splash_timer, scroll_speed) / scroll_speed;
        double lines_visible = (height + 200.0) / line_height;
        
        // Use actual viewport bounds (1920x1080) since projection is hardcoded to those values
        const int viewport_width = 1920;
        
        // Draw all lines that could be visible
        for (int i = 0; i < (int)lines_visible + 2; i++) {
            int line_index = (int)current_line_offset + i;
            if (line_index < 0 || line_index >= num_crawl_lines) continue;
            
            // Calculate Y position (lines scroll up from bottom to top)
            double y_pos = height - (fractional_offset * line_height) + (i * line_height) - (current_line_offset * line_height);
            
            // Calculate fade for lines entering (bottom) and leaving (top)
            double alpha = 1.0;
            if (y_pos < 200.0) {
                alpha = y_pos / 200.0;
            } else if (y_pos > height - 200.0) {
                alpha = (height - y_pos) / 200.0;
            }
            
            if (alpha < 0.0) alpha = 0.0;
            if (alpha > 1.0) alpha = 1.0;
            
            gl_set_color_alpha(1.0f, 0.95f, 0.0f, (float)alpha);
            
            // Center text horizontally using actual text width
            float text_width = gl_calculate_text_width(crawl_lines[line_index], 24);
            float ideal_x = (viewport_width - text_width) / 2.0f;
            // Clamp to viewport bounds: min 30px margin to prevent cutoff (text can be long)
            int x_pos = (int)ideal_x;
            if (x_pos < 30) x_pos = 30;
            if (x_pos + text_width > viewport_width - 30) x_pos = viewport_width - (int)text_width - 30;
            gl_draw_text_simple(crawl_lines[line_index], x_pos, (int)y_pos, 24);
        }
    }
    // ===== TITLE PHASE =====
    // After crawl ends, show big COMET BUSTERS title
    else if (game->splash_timer < 43.0) {
        // Fade in the title
        double phase_timer = game->splash_timer - 38.0;
        double title_alpha = phase_timer / 2.0;
        if (title_alpha > 1.0) title_alpha = 1.0;
        
        const int viewport_width = 1920;
        
        // Draw glowing text effect
        const char *title_text = "COMET BUSTERS";
        float title_width = gl_calculate_text_width(title_text, 120);
        float ideal_title_x = (viewport_width - title_width) / 2.0f;
        int title_x = (int)ideal_title_x;
        // Clamp to viewport bounds with safe margin
        if (title_x < 30) title_x = 30;
        if (title_x + title_width > viewport_width - 30) title_x = viewport_width - (int)title_width - 30;
        int title_y = height / 2 + 20;
        
        for (int i = 5; i > 0; i--) {
            double alpha = 0.1 * (5 - i) / 5.0 * title_alpha;
            gl_set_color_alpha(0.0f, 1.0f, 1.0f, (float)alpha);
            gl_draw_text_simple(title_text, title_x, title_y, 120);
        }
        
        // Draw bright main title text
        gl_set_color_alpha(0.0f, 1.0f, 1.0f, (float)title_alpha);
        gl_draw_text_simple(title_text, title_x, title_y, 120);
        
        // Draw subtitle
        const char *subtitle = subtitle_texts[game->current_language];
        float subtitle_width = gl_calculate_text_width(subtitle, 28);
        float ideal_subtitle_x = (viewport_width - subtitle_width) / 2.0f;
        int subtitle_x = (int)ideal_subtitle_x;
        // Clamp to viewport bounds with safe margin
        if (subtitle_x < 30) subtitle_x = 30;
        if (subtitle_x + subtitle_width > viewport_width - 30) subtitle_x = viewport_width - (int)subtitle_width - 30;
        int subtitle_y = title_y + 80;
        
        // Blinking text effect for subtitle
        double blink_alpha = 0.5 + 0.5 * sin(game->splash_timer * 3.0);
        gl_set_color_alpha(1.0f, 1.0f, 0.0f, (float)(blink_alpha * title_alpha));
        gl_draw_text_simple(subtitle, subtitle_x, subtitle_y, 28);
    }
    // ===== WAIT PHASE =====
    // Just show the title and wait for input
    else {
        gl_set_color(0.0f, 1.0f, 1.0f);
        
        const int viewport_width = 1920;
        
        const char *title_text = "COMET BUSTERS";
        float title_width = gl_calculate_text_width(title_text, 120);
        float ideal_title_x = (viewport_width - title_width) / 2.0f;
        int title_x = (int)ideal_title_x;
        // Clamp to viewport bounds with safe margin
        if (title_x < 30) title_x = 30;
        if (title_x + title_width > viewport_width - 30) title_x = viewport_width - (int)title_width - 30;
        int title_y = height / 2 + 20;
        
        gl_draw_text_simple(title_text, title_x, title_y, 120);
        
        // Draw subtitle
        const char *subtitle = subtitle_texts[game->current_language];
        float subtitle_width = gl_calculate_text_width(subtitle, 28);
        float ideal_subtitle_x = (viewport_width - subtitle_width) / 2.0f;
        int subtitle_x = (int)ideal_subtitle_x;
        // Clamp to viewport bounds with safe margin
        if (subtitle_x < 30) subtitle_x = 30;
        if (subtitle_x + subtitle_width > viewport_width - 30) subtitle_x = viewport_width - (int)subtitle_width - 30;
        int subtitle_y = title_y + 80;
        
        // Blinking text effect for subtitle
        double blink_alpha = 0.5 + 0.5 * sin(game->splash_timer * 3.0);
        gl_set_color_alpha(1.0f, 1.0f, 0.0f, (float)blink_alpha);
        gl_draw_text_simple(subtitle, subtitle_x, subtitle_y, 28);
    }
}

void comet_buster_draw_victory_scroll_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game || !game->splash_screen_active || game->game_won == false) return;
    
    double timer = game->splash_timer;
    
    // Draw semi-transparent black background
    gl_set_color_alpha(0.0f, 0.0f, 0.0f, 0.95f);
    gl_draw_rect_filled(0.0f, 0.0f, (float)width, (float)height);
    
    // GET LANGUAGE-SPECIFIC ARRAYS
    const char **victory_lines = get_victory_scroll_for_language(game->current_language);
    int num_victory_lines = get_num_victory_lines_for_language(game->current_language);
    
    // Setup text
    gl_set_color(1.0f, 1.0f, 0.0f);
    
    // Calculate scroll
    double line_duration = 0.8;  // Seconds per line
    int start_line = (int)(timer / line_duration);
    double line_alpha = 1.0 - fmod(timer, line_duration) / (line_duration * 0.3);
    line_alpha = (line_alpha < 0) ? 0 : (line_alpha > 1) ? 1 : line_alpha;
    
    const int viewport_width = 1920;
    
    // Draw visible lines
    int y_pos = height / 3;
    for (int i = 0; i < 8 && start_line + i < num_victory_lines; i++) {
        double fade = 1.0;
        
        // First line fades in
        if (i == 0) {
            fade = line_alpha;
        }
        // Last visible line fades out
        if (i == 7) {
            fade = 1.0 - (double)i / 10.0;
        }
        
        gl_set_color_alpha(1.0f, 1.0f, 0.0f, (float)fade);
        
        // Center text horizontally using actual text width
        const char *line_text = victory_lines[start_line + i];
        float text_width = gl_calculate_text_width(line_text, 24);
        float ideal_x = (viewport_width - text_width) / 2.0f;
        // Clamp to viewport bounds with safe margin to prevent cutoff
        int x_pos = (int)ideal_x;
        if (x_pos < 30) x_pos = 30;
        if (x_pos + text_width > viewport_width - 30) x_pos = viewport_width - (int)text_width - 30;
        
        gl_draw_text_simple(line_text, x_pos, y_pos + i * 40, 24);
    }
}

void comet_buster_draw_finale_splash_gl(CometBusterGame *game, void *cr, int width, int height) {
    if (!game || !game->finale_splash_active) return;
    
    // Semi-transparent dark overlay
    gl_set_color_alpha(0.0f, 0.0f, 0.0f, 0.75f);
    gl_draw_rect_filled(0.0f, 0.0f, (float)width, (float)height);
    
    // Title "WAVE 30 COMPLETE"
    gl_set_color(1.0f, 1.0f, 0.0f);
    const char *title = wave_complete_text[game->current_language];
    float title_width = gl_calculate_text_width(title, 36);
    float title_x = (width - title_width) / 2.0f;
    gl_draw_text_simple(title, (int)title_x, 80, 36);
    
    // GET LANGUAGE-SPECIFIC ARRAYS
    const char **victory_lines = get_victory_scroll_for_language(game->current_language);
    int num_victory_lines = get_num_victory_lines_for_language(game->current_language);
    
    // Victory scroll text - scrolling effect
    gl_set_color(0.2f, 0.8f, 1.0f);
    
    int visible_lines = 40;  // Show 40 lines at a time
    int start_line = (game->finale_scroll_line_index > visible_lines) ? 
                     (game->finale_scroll_line_index - visible_lines) : 0;
    
    float y_pos = 150.0f;
    for (int i = start_line; i <= game->finale_scroll_line_index && i < num_victory_lines; i++) {
        const char *line_text = victory_lines[i];
        float text_width = gl_calculate_text_width(line_text, 15);
        float text_x = (width - text_width) / 2.0f;
        gl_draw_text_simple(line_text, (int)text_x, (int)y_pos, 15);
        y_pos += 22.0f;
    }
    
    // Show "RIGHT-CLICK TO CONTINUE TO WAVE 31" when done scrolling
    if (game->finale_waiting_for_input) {
        double pulse = 0.5 + 0.5 * sin(game->finale_splash_timer * 2.5);
        gl_set_color_alpha(1.0f, 1.0f, 0.0f, (float)pulse);
        
        const char *continue_text = continue_texts[game->current_language];
        float continue_width = gl_calculate_text_width(continue_text, 16);
        float continue_x = (width - continue_width) / 2.0f;
        gl_draw_text_simple(continue_text, (int)continue_x, height - 50, 16);
    }
}

void comet_buster_update_victory_scroll_gl(CometBusterGame *game, double dt) {}

void comet_buster_update_finale_splash_gl(CometBusterGame *game, double dt) {
    if (!game || !game->finale_splash_active) return;
    
    // GET LANGUAGE-SPECIFIC LINE COUNT
    int num_victory_lines = get_num_victory_lines_for_language(game->current_language);
    
    game->finale_splash_timer += dt;
    game->finale_scroll_timer += dt;
    
    // Auto-advance text lines every 0.6 seconds
    if (game->finale_scroll_timer >= 0.6) {
        game->finale_scroll_line_index++;
        game->finale_scroll_timer = 0.0;
        
        // When we reach the end, wait for input
        if (game->finale_scroll_line_index >= num_victory_lines) {
            game->finale_waiting_for_input = true;
            game->finale_scroll_line_index = num_victory_lines - 1;
        }
    }
}
